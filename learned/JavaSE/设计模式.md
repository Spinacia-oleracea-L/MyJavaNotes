# 设计模式的分类

| 序号 | 模式 & 描述                                                  | 包括                                                         |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1    | **创建型模式**：这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用**new**关键字直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更灵活。 | 工厂模式（Factory Pattern）抽象工厂模式（Abstract Factory Pattern）单例模式（Singleton Pattern）创建者模式（Builder Pattern）原型模式（Prototype Pattern） |
| 2    | **结构型模式**：这些设计模式关注**类**和**对象**的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 | 适配器模式（Adapter Pattern）桥接模式（Bridge Pattern）过滤器模式（Filter、Criteria Pattern）组合模式（Composite Pattern）装饰器模式（Decorator Pattern）外观模式（Facade Pattern）享元模式（Flyweight Pattern）代理模式（Proxy Pattern） |
| 3    | **行为型模式**：这些设计模式特别关注对象之间的通信。         | 责任链模式（Chain of Responsibility Pattern）命令模式（Command Pattern）解释器模式（Interpreter Pattern）迭代器模式（Iterator Pattern）中介者模式（Mediator Pattern）备忘录模式（Memento Pattern）观察者模式（Observer Pattern）状态模式（State Pattern）空对象模式（Null Object Pattern）策略模式（Strategy Pattern）模板模式（Template Pattern）访问者模式（Visitor Pattern） |
| 4    | **J2EE模式**：这些模式特别关注表示层。这些模式是由Sun Java Center 鉴定的。 | MVC模式（MVC Pattern）业务代表模式（Business Delegate Pattern）组合实体模式（Composite Entity Pattern）数据访问对象模式（Data Access Object Pattern）前端控制器模式（Front Controller Pattern）拦截过滤器模式（Intercepting Filter Pattern）服务定位器模式（Service Locator Pattern）传输对象模式（Transfer Object Pattern） |

# 创建型模式

## 一、单例模式

### 概述：

1. 所谓类的单例设计模式，就是采取一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。
2. 单例模式有两种方式：a.饿汉式b.懒汉式

#### a.饿汉式：

**不管需不需要一个对象，创建了再说。**
实现步骤：

1. 构造器私有化（防止new一个新对象）

2. 类的内部创建对象（为了照应3条的公共静态方法，需要使这个对象也是静态）

3. 向外暴露一个静态的公共方法（getInstance）

4. 代码实现
   ```java
    private GirlFriend(String name) { 
    	this.name = name; 
    } 
   
    private static GirlFriend gf = new GirlFriend("Tiffany"); 
   
    public static GirlFriend getInstance() { 
    	return gf; 
    }
   ```

#### b.懒汉式：

**只有需要使用对象时才创建。**
实现步骤：

1. 构造器私有化
2. 定义一个静态属性对象
3. 向外暴露一个静态的公共方法（getInstance）
4. 代码实现

```java
 private BoyFriend(String name) { 
 	System.out.println("构造器调用"); 
 	this.name = name; 
 } 

// 注意：未完成实例化，仅仅定义了
 private static BoyFriend bf; 

 public static BoyFriend getInstance(){ 
 	if(bf == null){ 
 		bf = new BoyFriend("Neo"); 
 	} 
 	return bf; 
 }
```

#### c.枚举实现：

延时加载，并发问题都得到了解决

```java
import java.util.concurrent.atomic.AtomicLong;
public enum IdGenerator {
    INSTANCE;
    private AtomicLong id = new AtomicLong(0);
    public long getId() {
        return id.incrementAndGet();
    }
    public static void main(String[] args) {
        IdGenerator instance = IdGenerator.INSTANCE;
        System.out.println(instance.getId());
    }
}
```

## 二、工厂模式

### a.简单工厂

#### 概述：

1. 工厂模式提供了一种将对象的实例化过程封装在工厂类中的方式。通过使用工厂模式，可以将对象的创建与使用代码分离，提供一种统一的**接口**来创建不同类型的对象。
2. 定义一个创建对象的**接口**，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。

#### 代码示例：

1. 创建一个**接口**:
   ```java
   public interface Shape {
      void draw();
   }
   ```

2. 创建实现接口的**实体类**。
   ```java
   public class Rectangle implements Shape {
    
      @Override
      public void draw() {
         System.out.println("Inside Rectangle::draw() method.");
      }
   }
   ```

   ```java
   public class Square implements Shape {
    
      @Override
      public void draw() {
         System.out.println("Inside Square::draw() method.");
      }
   }
   ```

   ```java
   public class Circle implements Shape {
    
      @Override
      public void draw() {
         System.out.println("Inside Circle::draw() method.");
      }
   }
   ```

3. **创建一个工厂**，生成基于给定信息的实体类的对象。

   ```java
   public class ShapeFactory {
       
      //使用 getShape 方法获取形状类型的对象
      public Shape getShape(String shapeType){
         if(shapeType == null){
            return null;
         }        
         if(shapeType.equalsIgnoreCase("CIRCLE")){
            return new Circle();
         } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
            return new Rectangle();
         } else if(shapeType.equalsIgnoreCase("SQUARE")){
            return new Square();
         }
         return null;
      }
   }
   ```

4. 使用该工厂，通过传递类型信息来获取实体类的对象。

   ```java
   public class FactoryPatternDemo {
    
      public static void main(String[] args) {
         ShapeFactory shapeFactory = new ShapeFactory();
    
         //获取 Circle 的对象，并调用它的 draw 方法
         Shape shape1 = shapeFactory.getShape("CIRCLE");
    
         //调用 Circle 的 draw 方法
         shape1.draw();
    
         //获取 Rectangle 的对象，并调用它的 draw 方法
         Shape shape2 = shapeFactory.getShape("RECTANGLE");
    
         //调用 Rectangle 的 draw 方法
         shape2.draw();
    
         //获取 Square 的对象，并调用它的 draw 方法
         Shape shape3 = shapeFactory.getShape("SQUARE");
    
         //调用 Square 的 draw 方法
         shape3.draw();
      }
   }
   ```

### b.抽象工厂

#### 概述：

1. 抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
2. **个人理解**：抽象工厂就像在简单工厂外面抽象出一层工厂，再通过getFactory()动态从接口的实现中，获得所需工厂。简单来说，**套娃**。

#### 代码示例：

1. 创建接口:

   * 形状接口
     ```java
     public interface Shape {
        void draw();
     }
     ```

   * 颜色接口

     ```java
     public interface Color {
        void fill();
     }
     ```

2. 创建实现接口的实体类

   * 形状的实例

     ```java
     public class Rectangle implements Shape {
      
        @Override
        public void draw() {
           System.out.println("Inside Rectangle::draw() method.");
        }
     }
     ```

     ```java
     public class Square implements Shape {
      
        @Override
        public void draw() {
           System.out.println("Inside Square::draw() method.");
        }
     }
     ```

     ```java
     public class Circle implements Shape {
      
        @Override
        public void draw() {
           System.out.println("Inside Circle::draw() method.");
        }
     }
     ```

   * 颜色的实例

     ```java
     public class Red implements Color {
      
        @Override
        public void fill() {
           System.out.println("Inside Red::fill() method.");
        }
     }
     ```

     ```java
     public class Green implements Color {
      
        @Override
        public void fill() {
           System.out.println("Inside Green::fill() method.");
        }
     }
     ```

     ```java
     public class Blue implements Color {
      
        @Override
        public void fill() {
           System.out.println("Inside Blue::fill() method.");
        }
     }
     ```

3. **为 Color 和 Shape 对象创建抽象类来获取工厂。**

   ```java
   public abstract class AbstractFactory {
      public abstract Color getColor(String color);
      public abstract Shape getShape(String shape);
   }
   ```

4. 创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成**实体类**的对象。

   * 形状工厂

     ```java
     public class ShapeFactory extends AbstractFactory {
         
        @Override
        public Shape getShape(String shapeType){
           if(shapeType == null){
              return null;
           }        
           if(shapeType.equalsIgnoreCase("CIRCLE")){
              return new Circle();
           } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
              return new Rectangle();
           } else if(shapeType.equalsIgnoreCase("SQUARE")){
              return new Square();
           }
           return null;
        }
        
        @Override
        public Color getColor(String color) {
           return null;
        }
     }
     ```

   * 颜色工厂

     ```java
     public class ColorFactory extends AbstractFactory {
         
        @Override
        public Shape getShape(String shapeType){
           return null;
        }
        
        @Override
        public Color getColor(String color) {
           if(color == null){
              return null;
           }        
           if(color.equalsIgnoreCase("RED")){
              return new Red();
           } else if(color.equalsIgnoreCase("GREEN")){
              return new Green();
           } else if(color.equalsIgnoreCase("BLUE")){
              return new Blue();
           }
           return null;
        }
     }
     ```

5. 创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂（**创造简单工厂的工厂**）。

   ```java
   public class FactoryProducer {
      public static AbstractFactory getFactory(String choice){
         if(choice.equalsIgnoreCase("SHAPE")){
            return new ShapeFactory();
         } else if(choice.equalsIgnoreCase("COLOR")){
            return new ColorFactory();
         }
         return null;
      }
   }
   ```

6. 使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。

   ```java
   public class AbstractFactoryPatternDemo {
      public static void main(String[] args) {
    
         //获取形状工厂
         AbstractFactory shapeFactory = FactoryProducer.getFactory("SHAPE");
    
         //获取形状为 Circle 的对象
         Shape shape1 = shapeFactory.getShape("CIRCLE");
    
         //调用 Circle 的 draw 方法
         shape1.draw();
    
         //获取形状为 Rectangle 的对象
         Shape shape2 = shapeFactory.getShape("RECTANGLE");
    
         //调用 Rectangle 的 draw 方法
         shape2.draw();
         
         //获取形状为 Square 的对象
         Shape shape3 = shapeFactory.getShape("SQUARE");
    
         //调用 Square 的 draw 方法
         shape3.draw();
    
         //获取颜色工厂
         AbstractFactory colorFactory = FactoryProducer.getFactory("COLOR");
    
         //获取颜色为 Red 的对象
         Color color1 = colorFactory.getColor("RED");
    
         //调用 Red 的 fill 方法
         color1.fill();
    
         //获取颜色为 Green 的对象
         Color color2 = colorFactory.getColor("GREEN");
    
         //调用 Green 的 fill 方法
         color2.fill();
    
         //获取颜色为 Blue 的对象
         Color color3 = colorFactory.getColor("BLUE");
    
         //调用 Blue 的 fill 方法
         color3.fill();
      }
   }
   ```

## 三、建造者模式

### 概述：

1. 一个对象实例化时，需要设定大量属性。（故，构造器模式不方便）
2. 这个对象的属性，一经创建就不再需要变化。（故，setter模式不方便）
3. 一些基本部件属性不会变，而其组合经常变化的时候。（故，构造器模式不方便）

### 代码示例：

1. 总结
   ```java
   public class ⽬标类(){
       //⽬标类的构造⽅法要求传⼊Builder对象
       public ⽬标类(Builder builder){
           
       }
       public 返回值 业务⽅法(参数列表){
           //doSth
       }
       
       //Builder建造者类位于⽬标类内部且⽤static描述
       public static class Builder(){
           //Builder建造者对象提供内置属性与各种set⽅法，注意set⽅法返回Builder对象本身
           private String xxx ;
           public Builder setXxx(String xxx) {
               this.xxx = xxx;
               return this;
           }
           //Builder建造者类提供build()⽅法实现⽬标类对象的创建
           public ⽬标类 build() {
               //业务校验
               return new ⽬标类(this);
           }
       }
   }
   ```

2. 示例

   ```java
   public class RabbitMQClient {
       private RabbitMQClient(Builder builder){
           
       }
       public void sendMessage(String msg) {
           System.out.println("正在发送消息：" + msg);
       }
       // Builder
       public static class Builder {
           private String host = "127.0.0.1";
           private int port = 5672;
           private int mode;
           private String exchange;
           private String queue;
           private boolean isDurable = true;
           private int connectionTimeout = 20;
           public Builder setHost(String host) {
               this.host = host;
               return this;
           }
           public Builder setPort(int port) {
               this.port = port;
               return this;
           }
           public Builder setMode(int mode) {
               this.mode = mode;
               return this;
           }
           public Builder setExchange(String exchange) {
               this.exchange = exchange;
               return this;
           }
           public Builder setQueue(String queue) {
               this.queue = queue;
               return this;
           }
           public Builder setDurable(boolean durable) {
               isDurable = durable;
               return this;
           }
           public RabbitMQClient build() {
               if(mode == 1){ //⼯作队列模式不需要设置交换机，但queue必填
                   if(exchange != null){
                       throw new RuntimeException("⼯作队列模式⽆须设计交换机");
                   }
                   if(queue == null || queue.trim().equals("")){
                       throw new RuntimeException("⼯作队列模式必须设置队列名称");
                   }
                   if(isDurable == false){
                       throw new RuntimeException("⼯作队列模式必须开启数据持久化");
                   }
               } else if(mode ==2) { //路由模式必须设置交换机，但不能设置queue队列
                   if(exchange == null || exchange.trim().equals("")){
                       throw new RuntimeException("路由模式请设置交换机");
                   }
                   if(queue != null){
                       throw new RuntimeException("路由模式⽆须设置队列名称");
                   }
               }
               //其他验证
               return new RabbitMQClient(this);
           }
       }
       public static void main(String[] args) {
           RabbitMQClient client = new RabbitMQClient.Builder()
               .setHost("192.168.31.201")
               .setMode(2)
               .setExchange("test-exchange")
               .build();
           client.sendMessage("Test");
       }
   }
   ```

## 四、原型模式

### 概述：

1. ⽤⼀个已经创建的实例作为原型，通过复制该原型对象来创建⼀个和原型相同或相似的新对象。在这⾥，原型实例指定了要创建的对象的种类。⽤这种⽅式创建对象⾮常⾼效，根本⽆须知道对象创建的细节。
2. 这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的**代价比较大**时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。

### 代码示例：

#### a.浅克隆

实例对象中的引用类型的属性，仍指向原有属性所指向的对象的内存地址。

1. 实现Clonable接口的clone()方法

   ```java
   public class Employee implements Cloneable{
       private String name;
       private Car car;
       public String getName() {
           return name;
       }
       public void setName(String name) {
           this.name = name;
       }
       public Car getCar() {
           return car;
       }
       public void setCar(Car car) {
           this.car = car;
       }
       //重写Clone⽅法
       @Override
       protected Object clone() throws CloneNotSupportedException {
           System.out.println("正在复制Employee对象");
           return super.clone();
       }
   }
   ```

2. 应用入口

   ```java
   public class App {
       public static void main(String[] args) throws CloneNotSupportedException {
           Employee king = new Employee();
           king.setName("King");
           Car car = new Car();
           car.setNumber("FBW 381");
           king.setCar(car);
           Employee cloneKing = (Employee)king.clone();
           System.out.println("King == CloneKing:" + (king == cloneKing));
           System.out.println("King.car == CloneKing.car:" + (king.getCar() == cloneKing.getCar()));
       }
   }
   ```

#### b.深克隆

创建⼀个新对象，属性中引⽤的其他对象也会被克隆，不再指向原有对象地址。

```java
import com.google.gson.Gson;
public class Employee{
    private String name;
    private Car car;
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public Car getCar() {
        return car;
    }
    public void setCar(Car car) {
        this.car = car;
    }
    //基于JSON实现深度序列化
    public Employee deepClone(){
        Gson gson = new Gson();
        String json = gson.toJson(this);
        System.out.println(json);
        Employee cloneObject = gson.fromJson(json, Employee.class);
        return cloneObject;
    }
}
```

# 结构型模式

## 一、门面（外观）模式

### 概述：

1. 外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。
2. 实际应用：
   * 去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。 
   * JAVA 的三层开发模式。

### 代码示例：

1. 复杂的子系统

   ```java
   public class DatabaseManager {
       public void startDbCluster(){
           System.out.println("正在远程启动MySQL应⽤集群");
       }
   }
   ```

   ```java
   public class CacheManager {
       public void initRedis(){
           System.out.println("正在启动并预热Redis应⽤缓存");
       }
   }
   ```

   ```java
   public class WebServerManager {
       public void loadWebApp(){
           System.out.println("正在加载并启动Web应⽤服务器");
       }
   }
   ```

2. 引入门面

   ```java
   public class ApplicationFacade {
       private CacheManager cacheManager = new CacheManager();
       private DatabaseManager dbManager = new DatabaseManager();
       private WebServerManager webManager = new WebServerManager();
       public void initSystem(){
           dbManager.startDbCluster();
           cacheManager.initRedis();
           webManager.loadWebApp();
       }
   }
   ```

3. Client调用

   ```java
   public class Client {
       public static void main(String[] args) {
           ApplicationFacade application = new ApplicationFacade();
           application.initSystem();
       }
   }
   ```

## 二、适配器模式

### 概述：

1. 适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。
2. 读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。

### 代码示例：

1. Adaptee

   ```java
   import java.util.List;
   import java.util.Map;
   public interface UserService {
       public Map findById();
       public List<Map> findUsers();
   }
   ```

   ```java
   public class UserServiceImpl implements UserService {
       public Map findById(){
           Map map = new LinkedHashMap();
           map.put("user_id", 1234);
           map.put("username", "zhangsan");
           return map;
       }
       public List<Map> findUsers(){
           List<Map> list = new ArrayList<>();
           for(int i = 0 ; i<=10 ; i++){
               Map map = new LinkedHashMap();
               map.put("user_id", new Random().nextInt(100000));
               map.put("username", "user"+i);
               list.add(map);
           }
           return list;
       }
   }
   ```

2. Target：目标需求与Adaptee存在差异

   ```java
   // 需要返回json格式的对象
   public interface SpecUserService {
       public String findByJId();
       public String findJUsers();
   }
   ```

3. Adapter

   ```java
   public class SpecUserServiceAdapter implements SpecUserService { // 1.实现target
       // 2.引入Adaptee
       private UserService userService;
       // 3.构造时引入Adaptee
       public SpecUserServiceAdapter(UserService userService){
           this.userService = userService;
       }
       public String findByJId() {
           Map user = userService.findById();
           String json = new Gson().toJson(user);
           return json;
       }
       public String findJUsers() {
           List<Map> users = userService.findUsers();
           String json = new Gson().toJson(users);
           return json;
       }
   }
   ```

4. Client

   ```java
   public class Client {
       public static void main(String[] args) {
           UserService userService = new UserServiceImpl();
           SpecUserService specUserService = new SpecUserServiceAdapter(userService);
           System.out.println(specUserService.findJUsers());
       }
   }
   ```

## 三、桥接模式

### 概述：

1. 桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。
2. 这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类，这两种类型的类可被结构化改变而互不影响。

### 代码示例：

1. 抽象接口

   ```java
   public interface Logger {
       public void info(String message);
       public void debug(String debug);
   }
   ```

   ```java
   public interface DbOperator {
       public void insert(Object obj);
   }
   ```

2. 拓展抽象

   ```java
   public class Log4jLogger implements Logger{
       @Override
       public void info(String message) {
           System.out.println("log4j->[INFO]" + message);
       }
       @Override
       public void debug(String message) {
           System.out.println("log4j->[debug]" + message);
       }
   }
   ```

   ```java
   public class LogbackLogger implements Logger{
       @Override
       public void info(String message) {
           System.out.println("logback->[INFO]" + message);
       }
       @Override
       public void debug(String message) {
           System.out.println("logback->[debug]" + message);
       }
   }
   ```

   ```java
   public class MongoOperator implements DbOperator {
       @Override
       public void insert(Object obj) {
           System.out.println(obj + "已写⼊MongoDB");
       }
   }
   ```

   ```java
   public class MysqlOperator implements DbOperator {
       @Override
       public void insert(Object obj) {
           System.out.println(obj + "已写⼊Redis");
       }
   }
   ```

3. 实现接口

   ```java
   public interface Service {
       public void init();
   }
   ```

4. 具体实现

   ```java
   import logger.Logger;
   import writer.DbOperator;
   public class EmployeeService implements Service {
       private DbOperator dbOperator = null;
       private Logger logger = null;
       public EmployeeService(DbOperator dbOperator, Logger logger) {
           this.dbOperator = dbOperator;
           this.logger = logger;
       }
       public void update(){
           dbOperator.insert("{员⼯A数据}");
           logger.info("数据更新成功");
       }
       @Override
       public void init() {
           ogger.info("EmployeeService已初始化完毕");
       }
   }
   
   ```

   ```java
   import logger.Logger;
   import writer.DbOperator;
   public class UserService implements Service {
       private DbOperator dbOperator = null;
       private Logger logger = null;
       public UserService(DbOperator dbOperator, Logger logger) {
           this.dbOperator = dbOperator;
           this.logger = logger;
       }
       public void create(){
           dbOperator.insert("{⽤户A数据}");
           logger.debug("数据插⼊成功");
       }
       @Override
       public void init() {
           logger.info("UserService已初始化完毕");
       }
   }
   ```

5. Client

   ```java
   public class Client {
       public static void main(String[] args) {
           EmployeeService employeeService = new EmployeeService(new MongoOperator(),new Log4jLogger());
           employeeService.init();
           employeeService.update();
           System.out.println("=======================");
           UserService userService = new UserService(new MysqlOperator(), new LogbackLogger());
           userService.init();
           userService.create();
       }
   }
   ```

## 四、组合模式

### 概述：

1. 将对象组合成树形结构以表示"部分-整体"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。
2. **使用场景：**部分、整体场景，如树形菜单，文件、文件夹的管理。

### 代码示例：

1. 构建

   ```java
   /**
    * OssNode抽象节点
    */
   public interface OssNode {
       public String getPath();
   }
   ```

   ```java
   import java.util.ArrayList;
   import java.util.List;
   /**
    * OSS⽬录类
    */
   public class OssDirectory implements OssNode {
       private List<OssNode> subNodes = new ArrayList<>();
       String path = null;
       /**
       * 指定绝对路径
       * @param path
       */
       public OssDirectory(String path){
           this.path = path;
       }
       /**
       * 指定⽗级⽬录，采⽤相对路径
       * @param parent 上级⽬录对象
       * @param dirName ⽬录名
       */
       public OssDirectory(OssDirectory parent , String dirName){
           parent.addChild(this);
           this.path = parent.getPath() + dirName;
       }
       /**
       * 得到当前⽬录路径
       * @return
       */
       @Override
       public String getPath() {
           return path;
       }
       /**
       * 增加⼦节点
       * @param node
       */
       public void addChild(OssNode node){
           this.subNodes.add(node);
       }
       /**
       * 移除⼦节点
       * @param node
       */
       public void removeChild(OssNode node){
           this.subNodes.remove(node);
       }
       /**
       * 返回所有⼦节点
       * @return
       */
       public List<OssNode> getChildren(){
           return this.subNodes;
       }
   }
   ```

   ```java
   /**
    * Oss⽂件对象
    */
   public class OssFile implements OssNode{
       private String filename;
       private OssDirectory ossDirectory;
       /**
       * 构造⽅法
       * @param dir 指定⽬录
       * @param filename ⽂件名
       */
       public OssFile(OssDirectory dir ,String filename) {
           this.ossDirectory = dir;
           //添加到指定节点
           dir.addChild(this);
           this.filename = filename;
       }
       /**
       * 得到⽂件路径
       * @return
       */
       @Override
       public String getPath() {
           return ossDirectory.getPath() + filename;
       }
   }
   ```

2. 输出

   ```java
   import java.util.List;
   public class Client {
       public static void main(String[] args) {
           //组织⽬录结构
           OssDirectory root = new OssDirectory("/root");
           OssDirectory dir1 = new OssDirectory(dir1,"/s1");
           OssDirectory dir14 = new OssDirectory(dir14,"/s4");
           OssDirectory dir145 = new OssDirectory(dir145,"/s5");
           OssDirectory dir2 = new OssDirectory(root,"/s2");
           OssDirectory dir3 = new OssDirectory(root,"/s3");
           //组织⽂件存放
           OssFile fil1 = new OssFile(dir1, "/f1.txt");
           OssFile fil2 = new OssFile(dir2, "/f2.png");
           OssFile fil3 = new OssFile(dir3, "/f3.gif");
           OssFile fil14 = new OssFile(dir14, "/f14.txt");
           OssFile fil145 = new OssFile(dir145, "/f145.svg");
           //实例化客户端递归打印所有节点路径
           Client client = new Client();
           client.printNodes(root);
       }
       /**
       * 递归打印所有节点路径
       * @param dir
       */
       public void printNodes(OssDirectory dir){
           List<OssNode> children = dir.getChildren();
           for (OssNode node : children) {
               System.out.println(node.getPath());
               if(node instanceof OssDirectory){
                   this.printNodes((OssDirectory) node);
               }
           }
       }
   }
   
   ```

## 五、享元模式

### 概述：

1. 在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。
2. 享元模式主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。

### 代码示例：

1. 抽离出共有的属性，作为元数据。属性需满足，各个字段都需要，不怎么改变

   ```java
   /*具体商品规格*/
   public class ComputerSpec {
       private String title;
       //品牌
       private String brand;
       //商品图⽂描述
       private String description;
       
       public ComputerSpec(String title, String brand, String description) {
           this.title = title;
           this.brand = brand;
           this.description = description;
       }
       public String getTitle() {
           return title;
       }
       public String getBrand() {
           return brand;
       }
       public String getDescription() {
           return description;
       }
   }
   ```

2. 引用元数据

   ```java
   public class Computer {
       //商品唯⼀编码
       private String sn;
       //规格对象
       private ComputerSpec spec;
       
       public String getSn() {
           return sn;
       }
       public void setSn(String sn) {
           this.sn = sn;
       }
       public ComputerSpec getSpec() {
           return spec;
       }
       public void setSpec(ComputerSpec spec) {
           this.spec = spec;
       }
   }
   ```

3. 用 HashMap 存储这些元数据的实例对象

   ```java
   import java.util.*;
   public class Vendor {
       // 关键实现
       private Map<String , ComputerSpec> specMap = new HashMap<>();
       public Vendor(){
           specMap.put("macbook14s" , new ComputerSpec("MateBook 14s","华为","英特尔Evo 12代酷睿标压i7 16G 1T/14.2英⼨90Hz触控"));
           specMap.put("bookpro14", new ComputerSpec("Xiaomi Book Pro 14","⼩⽶", "2.8K超清⼤师屏 R7-6800H标压 16G 512G"));
       }
       
       public void purchase(){
           List<Computer> warehouse = new ArrayList();
           for(int i = 0 ; i < 100 ; i++){
               Computer c = new Computer();
               c.setSn(UUID.randomUUID().toString());
               c.setSpec(specMap.get("macbook14s"));
               warehouse.add(c);
           }
           for(int i = 0 ; i < 1000 ; i++){
               Computer c = new Computer();
               c.setSn(UUID.randomUUID().toString());
               c.setSpec(specMap.get("bookpro14"));
               warehouse.add(c);
           }
       }
   }
   ```

## 六、装饰器模式

### 概述：

1. 装饰模式是⼀种结构型设计模式， 允许你通过将对象放⼊包含⾏为的特殊封装对象中来为原对象 绑定新的⾏为。
2. 装饰器模式通过将对象包装在装饰器类中，以便动态地修改其行为。这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。

### 代码示例：

1. 顶层抽象接口

   ```java
   public interface DataSource {
       void writeData(String data);
       String readData();
   }
   ```

2. 接口实现

   ```java
   import java.io.*;
   public class FileDataSource implements DataSource {
       private String name;
       public FileDataSource(String name) {
           this.name = name;
       }
       @Override
       public void writeData(String data) {
           File file = new File(name);
           try (OutputStream fos = new FileOutputStream(file)) {
               fos.write(data.getBytes(), 0, data.length());
           } catch (IOException ex) {
               System.out.println(ex.getMessage());
           }
       }
       @Override
       public String readData() {
           char[] buffer = null;
           File file = new File(name);
           try (FileReader reader = new FileReader(file)) {
               buffer = new char[(int) file.length()];
               reader.read(buffer);
           } catch (IOException ex) {
               System.out.println(ex.getMessage());
           }
           return new String(buffer);
       }
   }
   ```

3. Decorator

   * 装饰器1

     ```java
     import java.util.Base64;
     // 1.实现顶层抽象接口
     public class EncryptionDecorator implements DataSource {
         // 2.私有化一个顶层抽象
         private DataSource datasource;
         // 3.构造时暴露一个顶层抽象的接口
         public EncryptionDecorator(DataSource dataSource) {
             this.datasource = dataSource;
         }
         @Override
         public void writeData(String data) {
             // 重写方法时，完成拓展的逻辑
             datasource.writeData(encode(data));
         }
         @Override
         public String readData() {
             // 重写方法时，完成拓展的逻辑
             return decode(datasource.readData());
         }
         private String encode(String data) {
             byte[] result = data.getBytes();
             for (int i = 0; i < result.length; i++) {
                 result[i] += (byte) 1;
             }
             return Base64.getEncoder().encodeToString(result);
         }
         private String decode(String data) {
             byte[] result = Base64.getDecoder().decode(data);
             for (int i = 0; i < result.length; i++) {
                 result[i] -= (byte) 1;
             }
             return new String(result);
         }
     }
     ```

   * 装饰器2

     ```java
     import com.google.gson.Gson;
     import com.google.gson.reflect.TypeToken;
     import java.util.HashMap;
     import java.util.Map;
     // 1.实现顶层抽象接口
     public class JsonDecorator implements DataSource {
         // 2.私有化一个顶层抽象
         private DataSource dataSource;
         // 3.构造时暴露一个顶层抽象的接口
         public JsonDecorator(DataSource dataSource) {
             this.dataSource = dataSource;
         }
         @Override
         public void writeData(String data) {
             // 重写方法时，完成拓展的逻辑
             dataSource.writeData(toJson(data));
         }
         @Override
         public String readData() {
             // 重写方法时，完成拓展的逻辑
             return fromJson(dataSource.readData());
         }
         private String toJson(String stringData) {
             Map map = new HashMap();
             map.put("content", stringData);
             return new Gson().toJson(map);
         }
         private String fromJson(String json) {
             Map map = new Gson().fromJson(json,new TypeToken<Map<String,String>>(){}.getType());
             return map.get("content").toString();
         }
     }
     ```

4. Client

   ```java
   public class Client {
       public static void main(String[] args) {
           String salaryRecords = "Name,Salary / John Smith,100000 / Steven Jobs";
           // 1.注意Decorator的使用，包裹原有抽象实例
           // 2.注意Decorator的顺序，不可以乱序
           DataSource dataSource = new EncryptionDecorator(new JsonDecorator(new FileDataSource("d:/code/OutputDemo.txt")));
           dataSource.writeData(salaryRecords);
           DataSource plain = new FileDataSource("d:/code/OutputDemo.txt");
           System.out.println("- Data ----------------");
           System.out.println(salaryRecords);
           System.out.println("- EncodedContent --------------");
           System.out.println(plain.readData());
           System.out.println("- DecodedContent --------------");
           System.out.println(dataSource.readData());
       }
   }
   ```

## 七、代理模式

### 概述：

1. 在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。
2. **适用于**：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。
3. 注意事项： 
   * 和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 
   * 和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。
   * 补充：适配器模式和装饰器模式都可以在原类文件方法的基础上修改、增强，但侧重点不一样
     * 适配器模式重在将一个接口转换为另一个接口
     * 装饰器模式侧重对原类文件方法的增强，但接口还是同一个接口

### 代码示例：

1. 抽象接口及被代理对象

   ```java
   public interface Image {
      void display();
   }
   ```

   ```java
   public class RealImage implements Image {
    
      private String fileName;
    
      public RealImage(String fileName){
         this.fileName = fileName;
         loadFromDisk(fileName);
      }
    
      @Override
      public void display() {
         System.out.println("Displaying " + fileName);
      }
    
      private void loadFromDisk(String fileName){
         System.out.println("Loading " + fileName);
      }
   }
   ```

2. 代理Proxy

   ```java
   public class ProxyImage implements Image{
    
      // 1.代理的不是接口，而是实例对象
      private RealImage realImage;
      private String fileName;
    
      public ProxyImage(String fileName){
         this.fileName = fileName;
      }
    
      @Override
      public void display() {
         if(realImage == null){
            realImage = new RealImage(fileName);
         }
         realImage.display();
      }
   }
   ```

3. 调用Proxy

   ```java
   public class ProxyPatternDemo {
      
      public static void main(String[] args) {
         //使用代理去完成被代理对象的功能
         Image image = new ProxyImage("test_10mb.jpg");
    
         // 图像将从磁盘加载
         image.display(); 
         System.out.println("");
         // 图像不需要从磁盘加载
         image.display();  
      }
   }
   ```

# 行为型模式

## 一、责任链模式

### 概述：

1. 责任链模式Chain是⼀种⾏为设计模式， 允许你将请求沿着处理者链进⾏ 发送。 收到请求后， 每个处理者均可对请求进⾏处理， 或将其传递给 链上的下个处理者。
2. 当程序需要使⽤不同⽅式处理不同种类请求， ⽽且请求类型和顺序 预先未知时， 可以使⽤责任链模式。

### 代码示例：

1. 接口以及抽象类

   ```java
   public interface Handler {
       public void setNext(Handler next);
       public void handle(Map<String,Object> request);
   }
   ```

   ```java
   public abstract class AbstractHandler implements Handler {
       // 主要代码：向下传递接口
       private Handler next;
       public void setNext(Handler next) {
           this.next = next;
       }
       public Handler getNext() {
           return next;
       }
   }
   ```

2. 实现类

   * 认证处理器

     ```java
     import java.util.Map;
     public class AuthHandler extends AbstractHandler{
         @Override
         public void handle(Map<String,Object> request) {
             if(request.get("username").equals("admin") && request.get("password").equals("admin")){
                 System.out.println("⽤户信息认证通过");
                 if(this.getNext() != null){
                     this.getNext().handle(request);
                 }else{
                     throw new RuntimeException("请求没有被送达ProceedHandler");
                 }
             }else{
                 throw new RuntimeException("⽤户名或密码错误");
             }
         }
     }
     ```

   * 缓存处理器

     ```java
     import java.util.Map;
     public class CacheHandler extends AbstractHandler{
         @Override
         public void handle(Map<String,Object> request) {
             System.out.println("已将当前请求转存⾄Redis缓存");
             if(this.getNext() != null){
                 this.getNext().handle(request);
             }else{
                 throw new RuntimeException("请求没有被送达ProceedHandler");
             }
         }
     }
     ```

   * 指标收集处理器

     ```java
     import java.util.Map;
     public class MetricsHandler extends AbstractHandler{
         @Override
         public void handle(Map<String,Object> request) {
             System.out.println("已获取当前运⾏指标并发送⾄Prometheus");
             if(this.getNext() != null){
                 this.getNext().handle(request);
             }else{
                 throw new RuntimeException("请求没有被送达ProceedHandler");
             }
         }
     }
     ```

   * 业务转发处理器

     ```java
     import java.util.Map;
     public class ProceedHandler extends AbstractHandler{
         @Override
         public void handle(Map<String,Object> request) {
             System.out.println("请求已被转发给业务系统，完成后续业务处理");
         }
     }
     ```

3. 客户端

   ```java
   import java.util.HashMap;
   import java.util.Map;
   public class Client {
       public static void main(String[] args) {
           Handler authHandler = new AuthHandler();
           Handler cacheHandler = new CacheHandler();
           Handler metricsHandler = new MetricsHandler();
           Handler proceedHandler = new ProceedHandler();
           authHandler.setNext(metricsHandler);
           metricsHandler.setNext(cacheHandler);
           cacheHandler.setNext(proceedHandler);
           Map request = new HashMap<>();
           request.put("username", "admin");
           request.put("password", "admin");
           authHandler.handle(request);
       }
   }
   ```

## 二、命令模式

### 概述：

### 代码示例：

## 三、迭代器模式

## 四、中介者模式

## 五、观察者模式