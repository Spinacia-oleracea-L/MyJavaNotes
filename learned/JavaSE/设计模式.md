# 设计模式的分类

| 序号 | 模式 & 描述                                                  | 包括                                                         |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1    | **创建型模式**：这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用**new**关键字直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更灵活。 | 工厂模式（Factory Pattern）抽象工厂模式（Abstract Factory Pattern）单例模式（Singleton Pattern）创建者模式（Builder Pattern）原型模式（Prototype Pattern） |
| 2    | **结构型模式**：这些设计模式关注**类**和**对象**的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 | 适配器模式（Adapter Pattern）桥接模式（Bridge Pattern）过滤器模式（Filter、Criteria Pattern）组合模式（Composite Pattern）装饰器模式（Decorator Pattern）外观模式（Facade Pattern）享元模式（Flyweight Pattern）代理模式（Proxy Pattern） |
| 3    | **行为型模式**：这些设计模式特别关注对象之间的通信。         | 责任链模式（Chain of Responsibility Pattern）命令模式（Command Pattern）解释器模式（Interpreter Pattern）迭代器模式（Iterator Pattern）中介者模式（Mediator Pattern）备忘录模式（Memento Pattern）观察者模式（Observer Pattern）状态模式（State Pattern）空对象模式（Null Object Pattern）策略模式（Strategy Pattern）模板模式（Template Pattern）访问者模式（Visitor Pattern） |
| 4    | **J2EE模式**：这些模式特别关注表示层。这些模式是由Sun Java Center 鉴定的。 | MVC模式（MVC Pattern）业务代表模式（Business Delegate Pattern）组合实体模式（Composite Entity Pattern）数据访问对象模式（Data Access Object Pattern）前端控制器模式（Front Controller Pattern）拦截过滤器模式（Intercepting Filter Pattern）服务定位器模式（Service Locator Pattern）传输对象模式（Transfer Object Pattern） |

# 创建型模式

## 一、单例模式

### 概述：

1. 所谓类的单例设计模式，就是采取一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。
2. 单例模式有两种方式：a.饿汉式b.懒汉式

#### a.饿汉式：

**不管需不需要一个对象，创建了再说。**
实现步骤：

1. 构造器私有化（防止new一个新对象）

2. 类的内部创建对象（为了照应3条的公共静态方法，需要使这个对象也是静态）

3. 向外暴露一个静态的公共方法（getInstance）

4. 代码实现
   ```java
    private GirlFriend(String name) { 
    	this.name = name; 
    } 
   
    private static GirlFriend gf = new GirlFriend("Tiffany"); 
   
    public static GirlFriend getInstance() { 
    	return gf; 
    }
   ```

#### b.懒汉式：

**只有需要使用对象时才创建。**
实现步骤：

1. 构造器私有化
2. 定义一个静态属性对象
3. 向外暴露一个静态的公共方法（getInstance）
4. 代码实现

```java
 private BoyFriend(String name) { 
 	System.out.println("构造器调用"); 
 	this.name = name; 
 } 

// 注意：未完成实例化，仅仅定义了
 private static BoyFriend bf; 

 public static BoyFriend getInstance(){ 
 	if(bf == null){ 
 		bf = new BoyFriend("Neo"); 
 	} 
 	return bf; 
 }
```

#### c.枚举实现：

延时加载，并发问题都得到了解决

```java
import java.util.concurrent.atomic.AtomicLong;
public enum IdGenerator {
    INSTANCE;
    private AtomicLong id = new AtomicLong(0);
    public long getId() {
        return id.incrementAndGet();
    }
    public static void main(String[] args) {
        IdGenerator instance = IdGenerator.INSTANCE;
        System.out.println(instance.getId());
    }
}
```

## 二、工厂模式

### a.简单工厂

#### 概述：

1. 工厂模式提供了一种将对象的实例化过程封装在工厂类中的方式。通过使用工厂模式，可以将对象的创建与使用代码分离，提供一种统一的**接口**来创建不同类型的对象。
2. 定义一个创建对象的**接口**，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。

#### 代码示例：

1. 创建一个**接口**:
   ```java
   public interface Shape {
      void draw();
   }
   ```

2. 创建实现接口的**实体类**。
   ```java
   public class Rectangle implements Shape {
    
      @Override
      public void draw() {
         System.out.println("Inside Rectangle::draw() method.");
      }
   }
   ```

   ```java
   public class Square implements Shape {
    
      @Override
      public void draw() {
         System.out.println("Inside Square::draw() method.");
      }
   }
   ```

   ```java
   public class Circle implements Shape {
    
      @Override
      public void draw() {
         System.out.println("Inside Circle::draw() method.");
      }
   }
   ```

3. **创建一个工厂**，生成基于给定信息的实体类的对象。

   ```java
   public class ShapeFactory {
       
      //使用 getShape 方法获取形状类型的对象
      public Shape getShape(String shapeType){
         if(shapeType == null){
            return null;
         }        
         if(shapeType.equalsIgnoreCase("CIRCLE")){
            return new Circle();
         } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
            return new Rectangle();
         } else if(shapeType.equalsIgnoreCase("SQUARE")){
            return new Square();
         }
         return null;
      }
   }
   ```

4. 使用该工厂，通过传递类型信息来获取实体类的对象。

   ```java
   public class FactoryPatternDemo {
    
      public static void main(String[] args) {
         ShapeFactory shapeFactory = new ShapeFactory();
    
         //获取 Circle 的对象，并调用它的 draw 方法
         Shape shape1 = shapeFactory.getShape("CIRCLE");
    
         //调用 Circle 的 draw 方法
         shape1.draw();
    
         //获取 Rectangle 的对象，并调用它的 draw 方法
         Shape shape2 = shapeFactory.getShape("RECTANGLE");
    
         //调用 Rectangle 的 draw 方法
         shape2.draw();
    
         //获取 Square 的对象，并调用它的 draw 方法
         Shape shape3 = shapeFactory.getShape("SQUARE");
    
         //调用 Square 的 draw 方法
         shape3.draw();
      }
   }
   ```

### b.抽象工厂

#### 概述：

1. 抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
2. **个人理解**：抽象工厂就像在简单工厂外面抽象出一层工厂，再通过getFactory()动态从接口的实现中，获得所需工厂。简单来说，**套娃**。

#### 代码示例：

1. 创建接口:

   * 形状接口
     ```java
     public interface Shape {
        void draw();
     }
     ```

   * 颜色接口

     ```java
     public interface Color {
        void fill();
     }
     ```

2. 创建实现接口的实体类

   * 形状的实例

     ```java
     public class Rectangle implements Shape {
      
        @Override
        public void draw() {
           System.out.println("Inside Rectangle::draw() method.");
        }
     }
     ```

     ```java
     public class Square implements Shape {
      
        @Override
        public void draw() {
           System.out.println("Inside Square::draw() method.");
        }
     }
     ```

     ```java
     public class Circle implements Shape {
      
        @Override
        public void draw() {
           System.out.println("Inside Circle::draw() method.");
        }
     }
     ```

   * 颜色的实例

     ```java
     public class Red implements Color {
      
        @Override
        public void fill() {
           System.out.println("Inside Red::fill() method.");
        }
     }
     ```

     ```java
     public class Green implements Color {
      
        @Override
        public void fill() {
           System.out.println("Inside Green::fill() method.");
        }
     }
     ```

     ```java
     public class Blue implements Color {
      
        @Override
        public void fill() {
           System.out.println("Inside Blue::fill() method.");
        }
     }
     ```

3. **为 Color 和 Shape 对象创建抽象类来获取工厂。**

   ```java
   public abstract class AbstractFactory {
      public abstract Color getColor(String color);
      public abstract Shape getShape(String shape);
   }
   ```

4. 创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成**实体类**的对象。

   * 形状工厂

     ```java
     public class ShapeFactory extends AbstractFactory {
         
        @Override
        public Shape getShape(String shapeType){
           if(shapeType == null){
              return null;
           }        
           if(shapeType.equalsIgnoreCase("CIRCLE")){
              return new Circle();
           } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
              return new Rectangle();
           } else if(shapeType.equalsIgnoreCase("SQUARE")){
              return new Square();
           }
           return null;
        }
        
        @Override
        public Color getColor(String color) {
           return null;
        }
     }
     ```

   * 颜色工厂

     ```java
     public class ColorFactory extends AbstractFactory {
         
        @Override
        public Shape getShape(String shapeType){
           return null;
        }
        
        @Override
        public Color getColor(String color) {
           if(color == null){
              return null;
           }        
           if(color.equalsIgnoreCase("RED")){
              return new Red();
           } else if(color.equalsIgnoreCase("GREEN")){
              return new Green();
           } else if(color.equalsIgnoreCase("BLUE")){
              return new Blue();
           }
           return null;
        }
     }
     ```

5. 创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂（**创造简单工厂的工厂**）。

   ```java
   public class FactoryProducer {
      public static AbstractFactory getFactory(String choice){
         if(choice.equalsIgnoreCase("SHAPE")){
            return new ShapeFactory();
         } else if(choice.equalsIgnoreCase("COLOR")){
            return new ColorFactory();
         }
         return null;
      }
   }
   ```

6. 使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。

   ```java
   public class AbstractFactoryPatternDemo {
      public static void main(String[] args) {
    
         //获取形状工厂
         AbstractFactory shapeFactory = FactoryProducer.getFactory("SHAPE");
    
         //获取形状为 Circle 的对象
         Shape shape1 = shapeFactory.getShape("CIRCLE");
    
         //调用 Circle 的 draw 方法
         shape1.draw();
    
         //获取形状为 Rectangle 的对象
         Shape shape2 = shapeFactory.getShape("RECTANGLE");
    
         //调用 Rectangle 的 draw 方法
         shape2.draw();
         
         //获取形状为 Square 的对象
         Shape shape3 = shapeFactory.getShape("SQUARE");
    
         //调用 Square 的 draw 方法
         shape3.draw();
    
         //获取颜色工厂
         AbstractFactory colorFactory = FactoryProducer.getFactory("COLOR");
    
         //获取颜色为 Red 的对象
         Color color1 = colorFactory.getColor("RED");
    
         //调用 Red 的 fill 方法
         color1.fill();
    
         //获取颜色为 Green 的对象
         Color color2 = colorFactory.getColor("GREEN");
    
         //调用 Green 的 fill 方法
         color2.fill();
    
         //获取颜色为 Blue 的对象
         Color color3 = colorFactory.getColor("BLUE");
    
         //调用 Blue 的 fill 方法
         color3.fill();
      }
   }
   ```

## 三、建造者模式

### 概述：

1. 一个对象实例化时，需要设定大量属性。（故，构造器模式不方便）
2. 这个对象的属性，一经创建就不再需要变化。（故，setter模式不方便）
3. 一些基本部件属性不会变，而其组合经常变化的时候。（故，构造器模式不方便）

### 代码示例：

1. 总结
   ```java
   public class ⽬标类(){
       //⽬标类的构造⽅法要求传⼊Builder对象
       public ⽬标类(Builder builder){
           
       }
       public 返回值 业务⽅法(参数列表){
           //doSth
       }
       
       //Builder建造者类位于⽬标类内部且⽤static描述
       public static class Builder(){
           //Builder建造者对象提供内置属性与各种set⽅法，注意set⽅法返回Builder对象本身
           private String xxx ;
           public Builder setXxx(String xxx) {
               this.xxx = xxx;
               return this;
           }
           //Builder建造者类提供build()⽅法实现⽬标类对象的创建
           public ⽬标类 build() {
               //业务校验
               return new ⽬标类(this);
           }
       }
   }
   ```

2. 示例

   ```java
   public class RabbitMQClient {
       private RabbitMQClient(Builder builder){
           
       }
       public void sendMessage(String msg) {
           System.out.println("正在发送消息：" + msg);
       }
       // Builder
       public static class Builder {
           private String host = "127.0.0.1";
           private int port = 5672;
           private int mode;
           private String exchange;
           private String queue;
           private boolean isDurable = true;
           private int connectionTimeout = 20;
           public Builder setHost(String host) {
               this.host = host;
               return this;
           }
           public Builder setPort(int port) {
               this.port = port;
               return this;
           }
           public Builder setMode(int mode) {
               this.mode = mode;
               return this;
           }
           public Builder setExchange(String exchange) {
               this.exchange = exchange;
               return this;
           }
           public Builder setQueue(String queue) {
               this.queue = queue;
               return this;
           }
           public Builder setDurable(boolean durable) {
               isDurable = durable;
               return this;
           }
           public RabbitMQClient build() {
               if(mode == 1){ //⼯作队列模式不需要设置交换机，但queue必填
                   if(exchange != null){
                       throw new RuntimeException("⼯作队列模式⽆须设计交换机");
                   }
                   if(queue == null || queue.trim().equals("")){
                       throw new RuntimeException("⼯作队列模式必须设置队列名称");
                   }
                   if(isDurable == false){
                       throw new RuntimeException("⼯作队列模式必须开启数据持久化");
                   }
               } else if(mode ==2) { //路由模式必须设置交换机，但不能设置queue队列
                   if(exchange == null || exchange.trim().equals("")){
                       throw new RuntimeException("路由模式请设置交换机");
                   }
                   if(queue != null){
                       throw new RuntimeException("路由模式⽆须设置队列名称");
                   }
               }
               //其他验证
               return new RabbitMQClient(this);
           }
       }
       public static void main(String[] args) {
           RabbitMQClient client = new RabbitMQClient.Builder()
               .setHost("192.168.31.201")
               .setMode(2)
               .setExchange("test-exchange")
               .build();
           client.sendMessage("Test");
       }
   }
   ```

## 四、原型模式

### 概述：

1. ⽤⼀个已经创建的实例作为原型，通过复制该原型对象来创建⼀个和原型相同或相似的新对象。在这⾥，原型实例指定了要创建的对象的种类。⽤这种⽅式创建对象⾮常⾼效，根本⽆须知道对象创建的细节。
2. 这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的**代价比较大**时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。

### 代码示例：

#### a.浅克隆

实例对象中的引用类型的属性，仍指向原有属性所指向的对象的内存地址。

1. 实现Clonable接口的clone()方法

   ```java
   public class Employee implements Cloneable{
       private String name;
       private Car car;
       public String getName() {
           return name;
       }
       public void setName(String name) {
           this.name = name;
       }
       public Car getCar() {
           return car;
       }
       public void setCar(Car car) {
           this.car = car;
       }
       //重写Clone⽅法
       @Override
       protected Object clone() throws CloneNotSupportedException {
           System.out.println("正在复制Employee对象");
           return super.clone();
       }
   }
   ```

2. 应用入口

   ```java
   public class App {
       public static void main(String[] args) throws CloneNotSupportedException {
           Employee king = new Employee();
           king.setName("King");
           Car car = new Car();
           car.setNumber("FBW 381");
           king.setCar(car);
           Employee cloneKing = (Employee)king.clone();
           System.out.println("King == CloneKing:" + (king == cloneKing));
           System.out.println("King.car == CloneKing.car:" + (king.getCar() == cloneKing.getCar()));
       }
   }
   ```

#### b.深克隆

创建⼀个新对象，属性中引⽤的其他对象也会被克隆，不再指向原有对象地址。

```java
import com.google.gson.Gson;
public class Employee{
    private String name;
    private Car car;
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public Car getCar() {
        return car;
    }
    public void setCar(Car car) {
        this.car = car;
    }
    //基于JSON实现深度序列化
    public Employee deepClone(){
        Gson gson = new Gson();
        String json = gson.toJson(this);
        System.out.println(json);
        Employee cloneObject = gson.fromJson(json, Employee.class);
        return cloneObject;
    }
}
```

# 结构型模式

## 一、门面（外观）模式

### 概述：

1. 外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。
2. 实际应用：
   * 去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。 
   * JAVA 的三层开发模式。

### 代码示例：

1. 复杂的子系统

   ```java
   public class DatabaseManager {
       public void startDbCluster(){
           System.out.println("正在远程启动MySQL应⽤集群");
       }
   }
   ```

   ```java
   public class CacheManager {
       public void initRedis(){
           System.out.println("正在启动并预热Redis应⽤缓存");
       }
   }
   ```

   ```java
   public class WebServerManager {
       public void loadWebApp(){
           System.out.println("正在加载并启动Web应⽤服务器");
       }
   }
   ```

2. 引入门面

   ```java
   public class ApplicationFacade {
       private CacheManager cacheManager = new CacheManager();
       private DatabaseManager dbManager = new DatabaseManager();
       private WebServerManager webManager = new WebServerManager();
       public void initSystem(){
           dbManager.startDbCluster();
           cacheManager.initRedis();
           webManager.loadWebApp();
       }
   }
   ```

3. Client调用

   ```java
   public class Client {
       public static void main(String[] args) {
           ApplicationFacade application = new ApplicationFacade();
           application.initSystem();
       }
   }
   ```

## 二、适配器模式

### 概述：

1. 适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。
2. 读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。

### 代码示例：

1. Adaptee

   ```java
   import java.util.List;
   import java.util.Map;
   public interface UserService {
       public Map findById();
       public List<Map> findUsers();
   }
   ```

   ```java
   public class UserServiceImpl implements UserService {
       public Map findById(){
           Map map = new LinkedHashMap();
           map.put("user_id", 1234);
           map.put("username", "zhangsan");
           return map;
       }
       public List<Map> findUsers(){
           List<Map> list = new ArrayList<>();
           for(int i = 0 ; i<=10 ; i++){
               Map map = new LinkedHashMap();
               map.put("user_id", new Random().nextInt(100000));
               map.put("username", "user"+i);
               list.add(map);
           }
           return list;
       }
   }
   ```

2. Target：目标需求与Adaptee存在差异

   ```java
   // 需要返回json格式的对象
   public interface SpecUserService {
       public String findByJId();
       public String findJUsers();
   }
   ```

3. Adapter

   ```java
   public class SpecUserServiceAdapter implements SpecUserService { // 1.实现target
       // 2.引入Adaptee
       private UserService userService;
       // 3.构造时引入Adaptee
       public SpecUserServiceAdapter(UserService userService){
           this.userService = userService;
       }
       public String findByJId() {
           Map user = userService.findById();
           String json = new Gson().toJson(user);
           return json;
       }
       public String findJUsers() {
           List<Map> users = userService.findUsers();
           String json = new Gson().toJson(users);
           return json;
       }
   }
   ```

4. Client

   ```java
   public class Client {
       public static void main(String[] args) {
           UserService userService = new UserServiceImpl();
           SpecUserService specUserService = new SpecUserServiceAdapter(userService);
           System.out.println(specUserService.findJUsers());
       }
   }
   ```

## 三、桥接模式

### 概述：

1. 桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。
2. 这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类，这两种类型的类可被结构化改变而互不影响。

### 代码示例：

1. 抽象接口

   ```java
   public interface Logger {
       public void info(String message);
       public void debug(String debug);
   }
   ```

   ```java
   public interface DbOperator {
       public void insert(Object obj);
   }
   ```

2. 拓展抽象

   ```java
   public class Log4jLogger implements Logger{
       @Override
       public void info(String message) {
           System.out.println("log4j->[INFO]" + message);
       }
       @Override
       public void debug(String message) {
           System.out.println("log4j->[debug]" + message);
       }
   }
   ```

   ```java
   public class LogbackLogger implements Logger{
       @Override
       public void info(String message) {
           System.out.println("logback->[INFO]" + message);
       }
       @Override
       public void debug(String message) {
           System.out.println("logback->[debug]" + message);
       }
   }
   ```

   ```java
   public class MongoOperator implements DbOperator {
       @Override
       public void insert(Object obj) {
           System.out.println(obj + "已写⼊MongoDB");
       }
   }
   ```

   ```java
   public class MysqlOperator implements DbOperator {
       @Override
       public void insert(Object obj) {
           System.out.println(obj + "已写⼊Redis");
       }
   }
   ```

3. 实现接口

   ```java
   public interface Service {
       public void init();
   }
   ```

4. 具体实现

   ```java
   import logger.Logger;
   import writer.DbOperator;
   public class EmployeeService implements Service {
       private DbOperator dbOperator = null;
       private Logger logger = null;
       public EmployeeService(DbOperator dbOperator, Logger logger) {
           this.dbOperator = dbOperator;
           this.logger = logger;
       }
       public void update(){
           dbOperator.insert("{员⼯A数据}");
           logger.info("数据更新成功");
       }
       @Override
       public void init() {
           ogger.info("EmployeeService已初始化完毕");
       }
   }
   
   ```

   ```java
   import logger.Logger;
   import writer.DbOperator;
   public class UserService implements Service {
       private DbOperator dbOperator = null;
       private Logger logger = null;
       public UserService(DbOperator dbOperator, Logger logger) {
           this.dbOperator = dbOperator;
           this.logger = logger;
       }
       public void create(){
           dbOperator.insert("{⽤户A数据}");
           logger.debug("数据插⼊成功");
       }
       @Override
       public void init() {
           logger.info("UserService已初始化完毕");
       }
   }
   ```

5. Client

   ```java
   public class Client {
       public static void main(String[] args) {
           EmployeeService employeeService = new EmployeeService(new MongoOperator(),new Log4jLogger());
           employeeService.init();
           employeeService.update();
           System.out.println("=======================");
           UserService userService = new UserService(new MysqlOperator(), new LogbackLogger());
           userService.init();
           userService.create();
       }
   }
   ```

## 四、组合模式

### 概述：

1. 将对象组合成树形结构以表示"部分-整体"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。
2. **使用场景：**部分、整体场景，如树形菜单，文件、文件夹的管理。

### 代码示例：

1. 构建

   ```java
   /**
    * OssNode抽象节点
    */
   public interface OssNode {
       public String getPath();
   }
   ```

   ```java
   import java.util.ArrayList;
   import java.util.List;
   /**
    * OSS⽬录类
    */
   public class OssDirectory implements OssNode {
       private List<OssNode> subNodes = new ArrayList<>();
       String path = null;
       /**
       * 指定绝对路径
       * @param path
       */
       public OssDirectory(String path){
           this.path = path;
       }
       /**
       * 指定⽗级⽬录，采⽤相对路径
       * @param parent 上级⽬录对象
       * @param dirName ⽬录名
       */
       public OssDirectory(OssDirectory parent , String dirName){
           parent.addChild(this);
           this.path = parent.getPath() + dirName;
       }
       /**
       * 得到当前⽬录路径
       * @return
       */
       @Override
       public String getPath() {
           return path;
       }
       /**
       * 增加⼦节点
       * @param node
       */
       public void addChild(OssNode node){
           this.subNodes.add(node);
       }
       /**
       * 移除⼦节点
       * @param node
       */
       public void removeChild(OssNode node){
           this.subNodes.remove(node);
       }
       /**
       * 返回所有⼦节点
       * @return
       */
       public List<OssNode> getChildren(){
           return this.subNodes;
       }
   }
   ```

   ```java
   /**
    * Oss⽂件对象
    */
   public class OssFile implements OssNode{
       private String filename;
       private OssDirectory ossDirectory;
       /**
       * 构造⽅法
       * @param dir 指定⽬录
       * @param filename ⽂件名
       */
       public OssFile(OssDirectory dir ,String filename) {
           this.ossDirectory = dir;
           //添加到指定节点
           dir.addChild(this);
           this.filename = filename;
       }
       /**
       * 得到⽂件路径
       * @return
       */
       @Override
       public String getPath() {
           return ossDirectory.getPath() + filename;
       }
   }
   ```

2. 输出

   ```java
   import java.util.List;
   public class Client {
       public static void main(String[] args) {
           //组织⽬录结构
           OssDirectory root = new OssDirectory("/root");
           OssDirectory dir1 = new OssDirectory(dir1,"/s1");
           OssDirectory dir14 = new OssDirectory(dir14,"/s4");
           OssDirectory dir145 = new OssDirectory(dir145,"/s5");
           OssDirectory dir2 = new OssDirectory(root,"/s2");
           OssDirectory dir3 = new OssDirectory(root,"/s3");
           //组织⽂件存放
           OssFile fil1 = new OssFile(dir1, "/f1.txt");
           OssFile fil2 = new OssFile(dir2, "/f2.png");
           OssFile fil3 = new OssFile(dir3, "/f3.gif");
           OssFile fil14 = new OssFile(dir14, "/f14.txt");
           OssFile fil145 = new OssFile(dir145, "/f145.svg");
           //实例化客户端递归打印所有节点路径
           Client client = new Client();
           client.printNodes(root);
       }
       /**
       * 递归打印所有节点路径
       * @param dir
       */
       public void printNodes(OssDirectory dir){
           List<OssNode> children = dir.getChildren();
           for (OssNode node : children) {
               System.out.println(node.getPath());
               if(node instanceof OssDirectory){
                   this.printNodes((OssDirectory) node);
               }
           }
       }
   }
   
   ```

## 五、享元模式

### 概述：

1. 在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。
2. 享元模式主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。

### 代码示例：

1. 抽离出共有的属性，作为元数据。属性需满足，各个字段都需要，不怎么改变

   ```java
   /*具体商品规格*/
   public class ComputerSpec {
       private String title;
       //品牌
       private String brand;
       //商品图⽂描述
       private String description;
       
       public ComputerSpec(String title, String brand, String description) {
           this.title = title;
           this.brand = brand;
           this.description = description;
       }
       public String getTitle() {
           return title;
       }
       public String getBrand() {
           return brand;
       }
       public String getDescription() {
           return description;
       }
   }
   ```

2. 引用元数据

   ```java
   public class Computer {
       //商品唯⼀编码
       private String sn;
       //规格对象
       private ComputerSpec spec;
       
       public String getSn() {
           return sn;
       }
       public void setSn(String sn) {
           this.sn = sn;
       }
       public ComputerSpec getSpec() {
           return spec;
       }
       public void setSpec(ComputerSpec spec) {
           this.spec = spec;
       }
   }
   ```

3. 用 HashMap 存储这些元数据的实例对象

   ```java
   import java.util.*;
   public class Vendor {
       // 关键实现
       private Map<String , ComputerSpec> specMap = new HashMap<>();
       public Vendor(){
           specMap.put("macbook14s" , new ComputerSpec("MateBook 14s","华为","英特尔Evo 12代酷睿标压i7 16G 1T/14.2英⼨90Hz触控"));
           specMap.put("bookpro14", new ComputerSpec("Xiaomi Book Pro 14","⼩⽶", "2.8K超清⼤师屏 R7-6800H标压 16G 512G"));
       }
       
       public void purchase(){
           List<Computer> warehouse = new ArrayList();
           for(int i = 0 ; i < 100 ; i++){
               Computer c = new Computer();
               c.setSn(UUID.randomUUID().toString());
               c.setSpec(specMap.get("macbook14s"));
               warehouse.add(c);
           }
           for(int i = 0 ; i < 1000 ; i++){
               Computer c = new Computer();
               c.setSn(UUID.randomUUID().toString());
               c.setSpec(specMap.get("bookpro14"));
               warehouse.add(c);
           }
       }
   }
   ```

## 六、装饰器模式

### 概述：

1. 装饰模式是⼀种结构型设计模式， 允许你通过将对象放⼊包含⾏为的特殊封装对象中来为原对象 绑定新的⾏为。
2. 装饰器模式通过将对象包装在装饰器类中，以便动态地修改其行为。这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。

### 代码示例：

1. 顶层抽象接口

   ```java
   public interface DataSource {
       void writeData(String data);
       String readData();
   }
   ```

2. 接口实现

   ```java
   import java.io.*;
   public class FileDataSource implements DataSource {
       private String name;
       public FileDataSource(String name) {
           this.name = name;
       }
       @Override
       public void writeData(String data) {
           File file = new File(name);
           try (OutputStream fos = new FileOutputStream(file)) {
               fos.write(data.getBytes(), 0, data.length());
           } catch (IOException ex) {
               System.out.println(ex.getMessage());
           }
       }
       @Override
       public String readData() {
           char[] buffer = null;
           File file = new File(name);
           try (FileReader reader = new FileReader(file)) {
               buffer = new char[(int) file.length()];
               reader.read(buffer);
           } catch (IOException ex) {
               System.out.println(ex.getMessage());
           }
           return new String(buffer);
       }
   }
   ```

3. Decorator

   * 装饰器1

     ```java
     import java.util.Base64;
     // 1.实现顶层抽象接口
     public class EncryptionDecorator implements DataSource {
         // 2.私有化一个顶层抽象
         private DataSource datasource;
         // 3.构造时暴露一个顶层抽象的接口
         public EncryptionDecorator(DataSource dataSource) {
             this.datasource = dataSource;
         }
         @Override
         public void writeData(String data) {
             // 重写方法时，完成拓展的逻辑
             datasource.writeData(encode(data));
         }
         @Override
         public String readData() {
             // 重写方法时，完成拓展的逻辑
             return decode(datasource.readData());
         }
         private String encode(String data) {
             byte[] result = data.getBytes();
             for (int i = 0; i < result.length; i++) {
                 result[i] += (byte) 1;
             }
             return Base64.getEncoder().encodeToString(result);
         }
         private String decode(String data) {
             byte[] result = Base64.getDecoder().decode(data);
             for (int i = 0; i < result.length; i++) {
                 result[i] -= (byte) 1;
             }
             return new String(result);
         }
     }
     ```

   * 装饰器2

     ```java
     import com.google.gson.Gson;
     import com.google.gson.reflect.TypeToken;
     import java.util.HashMap;
     import java.util.Map;
     // 1.实现顶层抽象接口
     public class JsonDecorator implements DataSource {
         // 2.私有化一个顶层抽象
         private DataSource dataSource;
         // 3.构造时暴露一个顶层抽象的接口
         public JsonDecorator(DataSource dataSource) {
             this.dataSource = dataSource;
         }
         @Override
         public void writeData(String data) {
             // 重写方法时，完成拓展的逻辑
             dataSource.writeData(toJson(data));
         }
         @Override
         public String readData() {
             // 重写方法时，完成拓展的逻辑
             return fromJson(dataSource.readData());
         }
         private String toJson(String stringData) {
             Map map = new HashMap();
             map.put("content", stringData);
             return new Gson().toJson(map);
         }
         private String fromJson(String json) {
             Map map = new Gson().fromJson(json,new TypeToken<Map<String,String>>(){}.getType());
             return map.get("content").toString();
         }
     }
     ```

4. Client

   ```java
   public class Client {
       public static void main(String[] args) {
           String salaryRecords = "Name,Salary / John Smith,100000 / Steven Jobs";
           // 1.注意Decorator的使用，包裹原有抽象实例
           // 2.注意Decorator的顺序，不可以乱序
           DataSource dataSource = new EncryptionDecorator(new JsonDecorator(new FileDataSource("d:/code/OutputDemo.txt")));
           dataSource.writeData(salaryRecords);
           DataSource plain = new FileDataSource("d:/code/OutputDemo.txt");
           System.out.println("- Data ----------------");
           System.out.println(salaryRecords);
           System.out.println("- EncodedContent --------------");
           System.out.println(plain.readData());
           System.out.println("- DecodedContent --------------");
           System.out.println(dataSource.readData());
       }
   }
   ```

## 七、代理模式

### 概述：

1. 在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。
2. **适用于**：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。
3. 注意事项： 
   * 和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 
   * 和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。
   * 补充：适配器模式和装饰器模式都可以在原类文件方法的基础上修改、增强，但侧重点不一样
     * 适配器模式重在将一个接口转换为另一个接口
     * 装饰器模式侧重对原类文件方法的增强，但接口还是同一个接口

### 代码示例：

1. 抽象接口及被代理对象

   ```java
   public interface Image {
      void display();
   }
   ```

   ```java
   public class RealImage implements Image {
    
      private String fileName;
    
      public RealImage(String fileName){
         this.fileName = fileName;
         loadFromDisk(fileName);
      }
    
      @Override
      public void display() {
         System.out.println("Displaying " + fileName);
      }
    
      private void loadFromDisk(String fileName){
         System.out.println("Loading " + fileName);
      }
   }
   ```

2. 代理Proxy

   ```java
   public class ProxyImage implements Image{
    
      // 1.代理的不是接口，而是实例对象
      private RealImage realImage;
      private String fileName;
    
      public ProxyImage(String fileName){
         this.fileName = fileName;
      }
    
      @Override
      public void display() {
         if(realImage == null){
            realImage = new RealImage(fileName);
         }
         realImage.display();
      }
   }
   ```

3. 调用Proxy

   ```java
   public class ProxyPatternDemo {
      
      public static void main(String[] args) {
         //使用代理去完成被代理对象的功能
         Image image = new ProxyImage("test_10mb.jpg");
    
         // 图像将从磁盘加载
         image.display(); 
         System.out.println("");
         // 图像不需要从磁盘加载
         image.display();  
      }
   }
   ```

# 行为型模式

## 一、责任链模式

### 概述：

1. 责任链模式Chain是⼀种⾏为设计模式， 允许你将请求沿着处理者链进⾏ 发送。 收到请求后， 每个处理者均可对请求进⾏处理， 或将其传递给 链上的下个处理者。
2. 当程序需要使⽤不同⽅式处理不同种类请求， ⽽且请求类型和顺序 预先未知时， 可以使⽤责任链模式。

### 代码示例：

1. 接口以及抽象类

   ```java
   public interface Handler {
       public void setNext(Handler next);
       public void handle(Map<String,Object> request);
   }
   ```

   ```java
   public abstract class AbstractHandler implements Handler {
       // 主要代码：向下传递接口
       private Handler next;
       public void setNext(Handler next) {
           this.next = next;
       }
       public Handler getNext() {
           return next;
       }
   }
   ```

2. 实现类

   * 认证处理器

     ```java
     import java.util.Map;
     public class AuthHandler extends AbstractHandler{
         @Override
         public void handle(Map<String,Object> request) {
             if(request.get("username").equals("admin") && request.get("password").equals("admin")){
                 System.out.println("⽤户信息认证通过");
                 if(this.getNext() != null){
                     this.getNext().handle(request);
                 }else{
                     throw new RuntimeException("请求没有被送达ProceedHandler");
                 }
             }else{
                 throw new RuntimeException("⽤户名或密码错误");
             }
         }
     }
     ```

   * 缓存处理器

     ```java
     import java.util.Map;
     public class CacheHandler extends AbstractHandler{
         @Override
         public void handle(Map<String,Object> request) {
             System.out.println("已将当前请求转存⾄Redis缓存");
             if(this.getNext() != null){
                 this.getNext().handle(request);
             }else{
                 throw new RuntimeException("请求没有被送达ProceedHandler");
             }
         }
     }
     ```

   * 指标收集处理器

     ```java
     import java.util.Map;
     public class MetricsHandler extends AbstractHandler{
         @Override
         public void handle(Map<String,Object> request) {
             System.out.println("已获取当前运⾏指标并发送⾄Prometheus");
             if(this.getNext() != null){
                 this.getNext().handle(request);
             }else{
                 throw new RuntimeException("请求没有被送达ProceedHandler");
             }
         }
     }
     ```

   * 业务转发处理器

     ```java
     import java.util.Map;
     public class ProceedHandler extends AbstractHandler{
         @Override
         public void handle(Map<String,Object> request) {
             System.out.println("请求已被转发给业务系统，完成后续业务处理");
         }
     }
     ```

3. 客户端

   ```java
   import java.util.HashMap;
   import java.util.Map;
   public class Client {
       public static void main(String[] args) {
           Handler authHandler = new AuthHandler();
           Handler cacheHandler = new CacheHandler();
           Handler metricsHandler = new MetricsHandler();
           Handler proceedHandler = new ProceedHandler();
           authHandler.setNext(metricsHandler);
           metricsHandler.setNext(cacheHandler);
           cacheHandler.setNext(proceedHandler);
           Map request = new HashMap<>();
           request.put("username", "admin");
           request.put("password", "admin");
           authHandler.handle(request);
       }
   }
   ```

## 二、命令模式

### 概述：

1. 命令模式Command是⼀种⾏为设计模式， 它可将请求转换为⼀个包含与请求相关的所有信息的独⽴对象。 该转换让你能根据不同的请求将⽅法参数化、 延迟请求执⾏或将其放⼊队列中， 且能实现可撤销操作。
2. 就像遥控器，本身不能制冷。但是可以操作空调制冷。

### 代码示例：

1. 待控制的功能（空调制冷）

   ```java
    public class Stock {
      
      private String name = "ABC";
      private int quantity = 10;
    
      public void buy(){
         System.out.println("Stock [ Name: "+name+", 
            Quantity: " + quantity +" ] bought");
      }
      public void sell(){
         System.out.println("Stock [ Name: "+name+", 
            Quantity: " + quantity +" ] sold");
      }
   }
   ```

2. 命令接口及实现（红外射频）

   ```java
   public interface Order {
      void execute();
   }
   ```

   ```java
   public class BuyStock implements Order {
      private Stock abcStock;
    
      public BuyStock(Stock abcStock){
         this.abcStock = abcStock;
      }
    
      public void execute() {
         abcStock.buy();
      }
   }
   ```

   ```java
   public class SellStock implements Order {
      private Stock abcStock;
    
      public SellStock(Stock abcStock){
         this.abcStock = abcStock;
      }
    
      public void execute() {
         abcStock.sell();
      }
   }
   ```

3. 命令控制集（遥控器）

   ```java
   import java.util.ArrayList;
   import java.util.List;
    
   public class Broker {
       // 核心实现
      private List<Order> orderList = new ArrayList<Order>(); 
    
      public void takeOrder(Order order){
         orderList.add(order);      
      }
    
      public void placeOrders(){
         for (Order order : orderList) {
            order.execute();
         }
         orderList.clear();
      }
   }
   ```

4. Client（用户）

   ```java
   public class CommandPatternDemo {
      public static void main(String[] args) {
         Stock abcStock = new Stock();
    
         BuyStock buyStockOrder = new BuyStock(abcStock);
         SellStock sellStockOrder = new SellStock(abcStock);
    
         Broker broker = new Broker();
         broker.takeOrder(buyStockOrder);
         broker.takeOrder(sellStockOrder);
    
         broker.placeOrders();
      }
   }
   ```

## 三、迭代器模式

### 概述：

1. 迭代器模式Iterator属于⾏为模式，提供⼀种⽅法访问⼀个容器对象中 各个元素，⽽⼜不暴露该对象的内部细节。

### 代码示例：

1. 待迭代实体

   ```java
   public class Employee {
       private String idno;
       private String name;
       private Integer age;
       private String skill;
       public Employee(String idno, String name, Integer age, String skill) {
           this.idno = idno;
           this.name = name;
           this.age = age;
           this.skill = skill;
       }
       public String getIdno() {
           return idno;
       }
       public void setIdno(String idno) {
           this.idno = idno;
       }
       public String getName() {
           return name;
       }
       public void setName(String name) {
           this.name = name;
       }
       public Integer getAge() {
           return age;
       }
       public void setAge(Integer age) {
           this.age = age;
       }
       public String getSkill() {
           return skill;
       }
       public void setSkill(String skill) {
           this.skill = skill;
       }
   }
   ```

2. 容器及容器实现

   ```java
   interface EmploymentMarket {
       public void add(String idno , String name , Integer age , String skill);
       public void remove(String idno);
       // 引入迭代器
       public Iterator iterator();
   }
   ```

   ```java
   import java.util.ArrayList;
   import java.util.List;
   public class EmploymentMarketImpl implements EmploymentMarket{
       // 将实体类属性分门别类地存储在不同的集合中
       List<String> idnoList = new ArrayList();
       List<String> nameList = new ArrayList();
       List<Integer> ageList = new ArrayList();
       List<String> skillList = new ArrayList();
       @Override
       public void add(String idno, String name, Integer age, String skill) {
           synchronized (this) {
               // 判别一下id字段在集合中不存在
               if(!idnoList.contains(idno)) {
                   idnoList.add(idno);
                   nameList.add(name);
                   ageList.add(age);
                   skillList.add(skill);
               }
           }
       }
       @Override
       public void remove(String idno) {
           synchronized (this) {
               int idx = idnoList.indexOf(idno);
               if(idx != -1) {
                   idnoList.remove(idx);
                   nameList.remove(idx);
                   ageList.remove(idx);
                   skillList.remove(idx);
               }
           }
       }
       @Override
       public Iterator iterator() {
           return new EmployeeIterator(idnoList,nameList,ageList,skillList);
       }
   }
   ```

3. 迭代器

   ```java
   interface Iterator {
       // 核心逻辑实现
       public Employee next();
       public boolean hasNext();
   }
   ```

   ```java
   import java.util.ArrayList;
   import java.util.List;
   public class EmployeeIterator implements Iterator{
       // 迭代游标
       int cursor = -1;
       List<String> idnoList;
       List<String> nameList;
       List<Integer> ageList;
       List<String> skillList;
       public EmployeeIterator(List<String> idnoList,
                               List<String> nameList,
                               List<Integer> ageList,
                               List<String> skillList) {
           this.idnoList = idnoList;
           this.nameList = nameList;
           this.ageList = ageList;
           this.skillList = skillList;
       }
       @Override
       public Employee next() {
           if(hasNext()) {
               // 判别游标后游标向后移动（+1）
               ++cursor;
               Employee employee = new Employee(idnoList.get(cursor),
                                                nameList.get(cursor),
                                                ageList.get(cursor),
                                                killList.get(cursor));
               return employee;
           }else{
               return null;
           }
       }
       @Override
       public boolean hasNext() {
           // 判别游标是否小于集合长度
           if(cursor < idnoList.size()-1){
               return true;
           }else {
               return false;
           }
       }
   }
   ```

4. Client

   ```java
   public class Client {
       public static void main(String[] args) {
           EmploymentMarket market = new EmploymentMarketImpl();
           market.add("130102XXXXXXXX0524","张燕",37,"IT产品销售");
           market.add("130104XXXXXXXX1928","李晶",28,"地产策划");
           market.add("130203XXXXXXXX0911","吴宇森",55,"电影导演");
           Iterator iterator = market.iterator();
           while (iterator.hasNext()){
               Employee employee = iterator.next();
               System.out.println(employee);
           }
       }
   }
   ```

## 四、中介者模式

### 概述：

1. 中介者模式Mediator属于⾏为模式， 能让你减少对象之间混乱⽆序的依赖关系。 该模式会限制对 象之间的直接交互， 迫使它们通过⼀个中介者对象进⾏合作。
2. 系统中对象之间存在⽐较复杂的引⽤关系，导致它们之间的依赖关系结 构混乱⽽且难以复⽤该对象。

### 代码示例：

1. 中介类

   ```java
   import java.util.Date;
    
   public class ChatRoom {
      public static void showMessage(User user, String message){
         System.out.println(new Date().toString()
            + " [" + user.getName() +"] : " + message);
      }
   }
   ```

2. 实体类

   ```java
   public class User {
      private String name;
    
      public String getName() {
         return name;
      }
    
      public void setName(String name) {
         this.name = name;
      }
    
      public User(String name){
         this.name  = name;
      }
    
      public void sendMessage(String message){
         ChatRoom.showMessage(this,message);
      }
   }
   ```

3. main

   ```java
   public class MediatorPatternDemo {
      public static void main(String[] args) {
         User robert = new User("Robert");
         User john = new User("John");
    
         robert.sendMessage("Hi! John!");
         john.sendMessage("Hello! Robert!");
      }
   }
   ```

## 五、观察者模式

### 概述：

1. 观察者模式Observer是⼀种⾏为设计模式， 允许你定义⼀种订阅机制， 可在对象事件发⽣时通知多个“观察” **该对象的其他对象**。
2. 适用场景：
   * 所有的发布订阅模式
   * 构建事件监听机制，比如按下按钮触发click事件
3. 观察者模式与中介者模式的区别：
   * 观察者是**单向**的，指代⼀个动作过后产⽣的后续观察者动作，反过来不成⽴。中介者是**双向**的，对象A能通过中介者联系到B，反之亦然。
   * 中介者的⽬标被称为同事，因为对象AB是平等的，⽽观察者的⽬标是因果关系，因为我做了XX动作，所以触发了观察者的XX动作。

### 代码示例：

1. 待监测的服务

   ```java
   public class Server {
       // 核心实现一个 ArrayList 存放观察者们
       private List<Observer> observers = new ArrayList<Observer>();
       private int cpu;
       private int memory;
       public void changeState(int cpu,int memory){
           this.cpu = cpu;
           this.memory = memory;
           System.out.println("CPU:" + cpu + "%,内存占⽤：" + memory + "%");
           notifyAllObservers();
       }
       public int getCpu() {
           return cpu;
       }
       public int getMemory() {
           return memory;
       }
       // 绑定观察者
       public void addObserver(Observer observer){
           observers.add(observer);
       }
       public void notifyAllObservers(){
           for (Observer observer : observers) {
               observer.update();
           }
       }
   }
   ```

2. Observer

   * 接口

     ```java
     public abstract class Observer {
         // Observer内部持有subject⽬标
         protected Server subject;
         public abstract void update();
     }
     ```

   * 实现

     ```java
     public class CpuObserver extends Observer{
         public CpuObserver(Server subject){
             this.subject = subject;
             // 绑定待观察的server
             this.subject.addObserver(this);
         }
         @Override
         public void update() {
             if(subject.getCpu() >= 80){
                 System.out.println("警报：CPU当前" + subject.getCpu()+ "%即将满载，请速查明原因");
             }
         }
     }
     ```

     ```java
     public class MemoryObserver extends Observer{
         public MemoryObserver(Server subject){
             this.subject = subject;
             // 绑定待观察的server
             this.subject.addObserver(this);
         }
         @Override
         public void update() {
             if(subject.getMemory() >= 80){
                 System.out.println("警报：服务器内存已占⽤超过" + subject.getMemory() + "%，请速查明原因");
             }
         }
     }
     ```

3. Client

   ```java
   import java.util.Random;
   public class Client {
       public static void main(String[] args) throws InterruptedException {
           Server subject = new Server();
           new CpuObserver(subject);
           new MemoryObserver(subject);
           while(true) {
               int cpu = new Random().nextInt(100);
               int memory = new Random().nextInt(100);
               subject.changeState(cpu, memory);
               Thread.sleep(5000);
           }
       }
   }
   ```

## 六、备忘录模式

### 概述：

1. 备忘录模式Memento是⼀种⾏为设计模式， 允许在不暴露对象实现细节 的情况下保存和恢复对象之前的状态。
2. 适用场景：
   * 后悔药
   * 打游戏时的存档
   * Windows 里的 ctrl + z
   * IE 中的后退
   * 数据库的事务管理。

### 代码示例：

1. 待备份的实体类

   ```java
   //原始对象
   public class Goods{
       private String title;
       private String description;
       private float price;
       public Goods() {
           
       }
       public Goods(String title, String description, float price) {
           this.title = title;
           this.description = description;
           this.price = price;
       }
       public String getTitle() {
           return title;
       }
       public void setTitle(String title) {
           this.title = title;
       }
       public String getDescription() {
           return description;
       }
       public void setDescription(String description) {
           this.description = description;
       }
       public float getPrice() {
           return price;
       }
       public void setPrice(float price) {
           this.price = price;
       }
       @Override
       public String toString() {
           return "Goods{" +
               "title='" + title + '\'' +
               ", description='" + description + '\'' +
               ", price=" + price + '}';
       }
   }
   ```

2. 创建 Memento 类（备忘录）

   ```java
   public interface Memento<T> {
       public T getSnapshot();
   }
   ```

   ```java
   import com.fasterxml.jackson.core.JsonProcessingException;
   import com.fasterxml.jackson.databind.ObjectMapper;
   //备忘录，⽤于创建对象副本
   public class MementoImpl<T> implements Memmento {
       // 副本快照
       private T snapshot;
       public MementoImpl(T snapshot) {
           this.snapshot = snapshot;
           ObjectMapper mapper = new ObjectMapper();
           try {
               // 采用Json序列化的方式，深克隆对象
               String json = mapper.writeValueAsString(snapshot);
               T clone = (T)mapper.readValue(json, snapshot.getClass());
               this.snapshot = clone;
           } catch (JsonProcessingException e) {
               throw new RuntimeException(e);
           }
       }
       public T getSnapshot() {
           return snapshot;
       }
   }
   ```

3. 创建 Originator 类（执⾏者）

   ```java
   /**
   * 执⾏者，内部持有原始对象的应⽤，同时提供创建、还原备忘录的⽅法
   * @author weichyang
   *
   */
   public class Originator<T> {
       //内部持有类的引⽤
       private T object = null;
       public Originator(T object){
           this.object = object;
       }
       public MementoImpl createMemento() {
           return new MementoImpl(object);
       }
       /**
       * 将发起⼈恢复到备忘录对象所记载的状态
       */
       public T restoreMemmento(Memmento memmento) {
           this.object = (T)memmento.getSnapshot();
           return object;
       }
   }
   ```

4. 创建 CareTaker 类（备忘录管理者）

   ```java
   import java.util.ArrayList;
   import java.util.List;
   /**
    * 备忘录管理者，⽤于管理不断变化的对象状态
    *
    */
   public class Caretaker {
       //对象变化拥有多个不同的备忘录
       private List<Memmento> memmentoList = new ArrayList<>();
       /**
       * 获取历史变化清单
       */
       public List<Memmento> getMemmentoList() {
           return this.memmentoList;
       }
       /**
       * 添加⼀个新的备忘录
       */
       public void addMemmemtos(Memmento memento) {
           this.memmentoList.add(memento);
       }
   }
   ```

5. Client

   ```java
   public class Client {
       /**
       * 客户端
       *
       * @param args
       */
       public static void main(String[] args) {
           //创建执⾏者，⽤于管理原始对象
           Originator<Goods> originator = new Originator(new Goods("⼩熊洗碗机", "...", 2389));
           //创建备忘录，留存最原始的记录
           MementoImpl<Goods> memento = originator.createMemento();
           Goods goods = originator.getObject();
           //创建管理者，⽤于管理备忘录的变化
           Caretaker caretaker = new Caretaker();
           //增加备忘录列表
           caretaker.addMememtos(memento);
           goods.setPrice(2208);
           caretaker.addMememtos(originator.createMemento());
           goods.setPrice(1998);
           goods.setDescription("双⼗⼀⼤促，低价1998");
           caretaker.addMememtos(originator.createMemento());
           //查看数据历史变化
           int i = 0;
           for (Memento m : caretaker.getMementoList()) {
               System.out.println(i + ":" + m.getSnapshot());
               i++;
           }
           Memento<Goods> m = caretaker.getMementoList().get(2);
           Goods o = originator.restoreMemmento(m);
           System.out.println("数据已恢复⾄指定节点状态");
           System.out.println(o);
       }
   }
   ```

## 七、策略模式

### 概述：

1. 在策略模式（Strategy Pattern）中一个类的行为或其算法可以在**运行时**更改。这种类型的设计模式属于行为型模式。
2. 在策略模式定义了一系列算法或策略，并将每个算法封装在独立的类中，使得它们可以互相替换。通过使用策略模式，可以在运行时根据需要选择不同的算法，而不需要修改客户端代码。
3. **注意**：一般结合工厂模式完成策略的选择

### 代码示例：

1. 抽象策略（Abstract Strategy）：

   ```java
   public interface Strategy {
      public int doOperation(int num1, int num2);
   }
   ```

2. 具体策略（Concrete Strategy）：

   ```java
   public class OperationAdd implements Strategy{
      @Override
      public int doOperation(int num1, int num2) {
         return num1 + num2;
      }
   }
   ```

   ```java
   public class OperationSubtract implements Strategy{
      @Override
      public int doOperation(int num1, int num2) {
         return num1 - num2;
      }
   }
   ```

   ```java
   public class OperationMultiply implements Strategy{
      @Override
      public int doOperation(int num1, int num2) {
         return num1 * num2;
      }
   }
   ```

3. 环境（Context）：

   ```java
   public class Context {
      private Strategy strategy;
    
      public Context(Strategy strategy){
         this.strategy = strategy;
      }
    
      public int executeStrategy(int num1, int num2){
         return strategy.doOperation(num1, num2);
      }
   }
   ```

4. main

   ```java
   public class StrategyPatternDemo {
      public static void main(String[] args) {
         Context context = new Context(new OperationAdd());    
         System.out.println("10 + 5 = " + context.executeStrategy(10, 5));
    
         context = new Context(new OperationSubtract());      
         System.out.println("10 - 5 = " + context.executeStrategy(10, 5));
    
         context = new Context(new OperationMultiply());    
         System.out.println("10 * 5 = " + context.executeStrategy(10, 5));
      }
   }
   ```

## 八、状态模式

### 概述：

1. 状态模式State是⼀种⾏为设计模式， 让你能在⼀个对象的内部状态变 化时改变其⾏为， 使其看上去就像改变了⾃身所属的类⼀样。
2. **适用场景**：代码中包含⼤量与对象状态有关的条件语句，可消除⼤量的 if...else...判断，将其剥离为⼀个个状态。
3. **状态模式与策略模式的区别**
   * 状态模式强调不同情况下对⽬标⽅法的控制，有的⽅法甚⾄不会执⾏ （例如抛异常）。策略模式的算法都是等价的，可以平替，不同算法虽然计算过程不同，但产⽣的是⼀致的。
   * 状态模式不会对Client暴露状态，是在上下⽂对象内部不断变化，⽽策略模式则是由Client⾃主决定使⽤哪种算法。

### 代码示例：

1. 状态接口：

   ```java
   public interface State {
       // 双向绑定
      public void doAction(Context context);
   }
   ```

2. 状态实例（**一个状态一个实例**）：

   ```java
   public class StartState implements State {
    
      public void doAction(Context context) {
         System.out.println("Player is in start state");
          // 双向绑定
         context.setState(this); 
      }
    
      public String toString(){
         return "Start State";
      }
   }
   ```

   ```java
   public class StopState implements State {
    
      public void doAction(Context context) {
         System.out.println("Player is in stop state");
          // 双向绑定
         context.setState(this); 
      }
    
      public String toString(){
         return "Stop State";
      }
   }
   ```

3. 环境上下文（Context）：

   ```java
   public class Context {
      private State state;
    
      public Context(){
         state = null;
      }
      // 双向绑定
      public void setState(State state){
         this.state = state;     
      }
    
      public State getState(){
         return state;
      }
   }
   ```

4. 调用上下文：

   ```java
   public class StatePatternDemo {
      public static void main(String[] args) {
         Context context = new Context();
    
         StartState startState = new StartState();
         startState.doAction(context);
         System.out.println(context.getState().toString());
    
         StopState stopState = new StopState();
         stopState.doAction(context);
         System.out.println(context.getState().toString());
      }
   }
   ```

## 九、模板模式

## 十、访问者模式

## 十一、解释器模式