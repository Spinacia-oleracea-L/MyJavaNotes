# 设计模式的分类

| 序号 | 模式 & 描述                                                  | 包括                                                         |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1    | **创建型模式**：这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用**new**关键字直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更灵活。 | 工厂模式（Factory Pattern）抽象工厂模式（Abstract Factory Pattern）单例模式（Singleton Pattern）创建者模式（Builder Pattern）原型模式（Prototype Pattern） |
| 2    | **结构型模式**：这些设计模式关注**类**和**对象**的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 | 适配器模式（Adapter Pattern）桥接模式（Bridge Pattern）过滤器模式（Filter、Criteria Pattern）组合模式（Composite Pattern）装饰器模式（Decorator Pattern）外观模式（Facade Pattern）享元模式（Flyweight Pattern）代理模式（Proxy Pattern） |
| 3    | **行为型模式**：这些设计模式特别关注对象之间的通信。         | 责任链模式（Chain of Responsibility Pattern）命令模式（Command Pattern）解释器模式（Interpreter Pattern）迭代器模式（Iterator Pattern）中介者模式（Mediator Pattern）备忘录模式（Memento Pattern）观察者模式（Observer Pattern）状态模式（State Pattern）空对象模式（Null Object Pattern）策略模式（Strategy Pattern）模板模式（Template Pattern）访问者模式（Visitor Pattern） |
| 4    | **J2EE模式**：这些模式特别关注表示层。这些模式是由Sun Java Center 鉴定的。 | MVC模式（MVC Pattern）业务代表模式（Business Delegate Pattern）组合实体模式（Composite Entity Pattern）数据访问对象模式（Data Access Object Pattern）前端控制器模式（Front Controller Pattern）拦截过滤器模式（Intercepting Filter Pattern）服务定位器模式（Service Locator Pattern）传输对象模式（Transfer Object Pattern） |

# 创建型模式

## 一、单例模式

### 概述：

1. 所谓类的单例设计模式，就是采取一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。
2. 单例模式有两种方式：a.饿汉式b.懒汉式

#### a.饿汉式：

**不管需不需要一个对象，创建了再说。**
实现步骤：

1. 构造器私有化（防止new一个新对象）

2. 类的内部创建对象（为了照应3条的公共静态方法，需要使这个对象也是静态）

3. 向外暴露一个静态的公共方法（getInstance）

4. 代码实现
   ```java
    private GirlFriend(String name) { 
    	this.name = name; 
    } 
   
    private static GirlFriend gf = new GirlFriend("Tiffany"); 
   
    public static GirlFriend getInstance() { 
    	return gf; 
    }
   ```

#### b.懒汉式：

**只有需要使用对象时才创建。**
实现步骤：

1. 构造器私有化
2. 定义一个静态属性对象
3. 向外暴露一个静态的公共方法（getInstance）
4. 代码实现

```java
 private BoyFriend(String name) { 
 	System.out.println("构造器调用"); 
 	this.name = name; 
 } 

// 注意：未完成实例化，仅仅定义了
 private static BoyFriend bf; 

 public static BoyFriend getInstance(){ 
 	if(bf == null){ 
 		bf = new BoyFriend("Neo"); 
 	} 
 	return bf; 
 }
```

#### c.枚举实现：

延时加载，并发问题都得到了解决

```java
import java.util.concurrent.atomic.AtomicLong;
public enum IdGenerator {
    INSTANCE;
    private AtomicLong id = new AtomicLong(0);
    public long getId() {
        return id.incrementAndGet();
    }
    public static void main(String[] args) {
        IdGenerator instance = IdGenerator.INSTANCE;
        System.out.println(instance.getId());
    }
}
```

## 二、工厂模式

### a.简单工厂

#### 概述：

1. 工厂模式提供了一种将对象的实例化过程封装在工厂类中的方式。通过使用工厂模式，可以将对象的创建与使用代码分离，提供一种统一的**接口**来创建不同类型的对象。
2. 定义一个创建对象的**接口**，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。

#### 代码示例：

1. 创建一个**接口**:
   ```java
   public interface Shape {
      void draw();
   }
   ```

2. 创建实现接口的**实体类**。
   ```java
   public class Rectangle implements Shape {
    
      @Override
      public void draw() {
         System.out.println("Inside Rectangle::draw() method.");
      }
   }
   ```

   ```java
   public class Square implements Shape {
    
      @Override
      public void draw() {
         System.out.println("Inside Square::draw() method.");
      }
   }
   ```

   ```java
   public class Circle implements Shape {
    
      @Override
      public void draw() {
         System.out.println("Inside Circle::draw() method.");
      }
   }
   ```

3. **创建一个工厂**，生成基于给定信息的实体类的对象。

   ```java
   public class ShapeFactory {
       
      //使用 getShape 方法获取形状类型的对象
      public Shape getShape(String shapeType){
         if(shapeType == null){
            return null;
         }        
         if(shapeType.equalsIgnoreCase("CIRCLE")){
            return new Circle();
         } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
            return new Rectangle();
         } else if(shapeType.equalsIgnoreCase("SQUARE")){
            return new Square();
         }
         return null;
      }
   }
   ```

4. 使用该工厂，通过传递类型信息来获取实体类的对象。

   ```java
   public class FactoryPatternDemo {
    
      public static void main(String[] args) {
         ShapeFactory shapeFactory = new ShapeFactory();
    
         //获取 Circle 的对象，并调用它的 draw 方法
         Shape shape1 = shapeFactory.getShape("CIRCLE");
    
         //调用 Circle 的 draw 方法
         shape1.draw();
    
         //获取 Rectangle 的对象，并调用它的 draw 方法
         Shape shape2 = shapeFactory.getShape("RECTANGLE");
    
         //调用 Rectangle 的 draw 方法
         shape2.draw();
    
         //获取 Square 的对象，并调用它的 draw 方法
         Shape shape3 = shapeFactory.getShape("SQUARE");
    
         //调用 Square 的 draw 方法
         shape3.draw();
      }
   }
   ```

### b.抽象工厂

#### 概述：

1. 抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
2. **个人理解**：抽象工厂就像在简单工厂外面抽象出一层工厂，再通过getFactory()动态从接口的实现中，获得所需工厂。简单来说，**套娃**。

#### 代码示例：

1. 创建接口:

   * 形状接口
     ```java
     public interface Shape {
        void draw();
     }
     ```

   * 颜色接口

     ```java
     public interface Color {
        void fill();
     }
     ```

2. 创建实现接口的实体类

   * 形状的实例

     ```java
     public class Rectangle implements Shape {
      
        @Override
        public void draw() {
           System.out.println("Inside Rectangle::draw() method.");
        }
     }
     ```

     ```java
     public class Square implements Shape {
      
        @Override
        public void draw() {
           System.out.println("Inside Square::draw() method.");
        }
     }
     ```

     ```java
     public class Circle implements Shape {
      
        @Override
        public void draw() {
           System.out.println("Inside Circle::draw() method.");
        }
     }
     ```

   * 颜色的实例

     ```java
     public class Red implements Color {
      
        @Override
        public void fill() {
           System.out.println("Inside Red::fill() method.");
        }
     }
     ```

     ```java
     public class Green implements Color {
      
        @Override
        public void fill() {
           System.out.println("Inside Green::fill() method.");
        }
     }
     ```

     ```java
     public class Blue implements Color {
      
        @Override
        public void fill() {
           System.out.println("Inside Blue::fill() method.");
        }
     }
     ```

3. **为 Color 和 Shape 对象创建抽象类来获取工厂。**

   ```java
   public abstract class AbstractFactory {
      public abstract Color getColor(String color);
      public abstract Shape getShape(String shape);
   }
   ```

4. 创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成**实体类**的对象。

   * 形状工厂

     ```java
     public class ShapeFactory extends AbstractFactory {
         
        @Override
        public Shape getShape(String shapeType){
           if(shapeType == null){
              return null;
           }        
           if(shapeType.equalsIgnoreCase("CIRCLE")){
              return new Circle();
           } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
              return new Rectangle();
           } else if(shapeType.equalsIgnoreCase("SQUARE")){
              return new Square();
           }
           return null;
        }
        
        @Override
        public Color getColor(String color) {
           return null;
        }
     }
     ```

   * 颜色工厂

     ```java
     public class ColorFactory extends AbstractFactory {
         
        @Override
        public Shape getShape(String shapeType){
           return null;
        }
        
        @Override
        public Color getColor(String color) {
           if(color == null){
              return null;
           }        
           if(color.equalsIgnoreCase("RED")){
              return new Red();
           } else if(color.equalsIgnoreCase("GREEN")){
              return new Green();
           } else if(color.equalsIgnoreCase("BLUE")){
              return new Blue();
           }
           return null;
        }
     }
     ```

5. 创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂（**创造简单工厂的工厂**）。

   ```java
   public class FactoryProducer {
      public static AbstractFactory getFactory(String choice){
         if(choice.equalsIgnoreCase("SHAPE")){
            return new ShapeFactory();
         } else if(choice.equalsIgnoreCase("COLOR")){
            return new ColorFactory();
         }
         return null;
      }
   }
   ```

6. 使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。

   ```java
   public class AbstractFactoryPatternDemo {
      public static void main(String[] args) {
    
         //获取形状工厂
         AbstractFactory shapeFactory = FactoryProducer.getFactory("SHAPE");
    
         //获取形状为 Circle 的对象
         Shape shape1 = shapeFactory.getShape("CIRCLE");
    
         //调用 Circle 的 draw 方法
         shape1.draw();
    
         //获取形状为 Rectangle 的对象
         Shape shape2 = shapeFactory.getShape("RECTANGLE");
    
         //调用 Rectangle 的 draw 方法
         shape2.draw();
         
         //获取形状为 Square 的对象
         Shape shape3 = shapeFactory.getShape("SQUARE");
    
         //调用 Square 的 draw 方法
         shape3.draw();
    
         //获取颜色工厂
         AbstractFactory colorFactory = FactoryProducer.getFactory("COLOR");
    
         //获取颜色为 Red 的对象
         Color color1 = colorFactory.getColor("RED");
    
         //调用 Red 的 fill 方法
         color1.fill();
    
         //获取颜色为 Green 的对象
         Color color2 = colorFactory.getColor("GREEN");
    
         //调用 Green 的 fill 方法
         color2.fill();
    
         //获取颜色为 Blue 的对象
         Color color3 = colorFactory.getColor("BLUE");
    
         //调用 Blue 的 fill 方法
         color3.fill();
      }
   }
   ```

## 三、建造者模式

### 概述：

1. 一个对象实例化时，需要设定大量属性。（故，构造器模式不方便）
2. 这个对象的属性，一经创建就不再需要变化。（故，setter模式不方便）
3. 一些基本部件属性不会变，而其组合经常变化的时候。（故，构造器模式不方便）

### 代码示例：

1. 总结
   ```java
   public class ⽬标类(){
       //⽬标类的构造⽅法要求传⼊Builder对象
       public ⽬标类(Builder builder){
           
       }
       public 返回值 业务⽅法(参数列表){
           //doSth
       }
       
       //Builder建造者类位于⽬标类内部且⽤static描述
       public static class Builder(){
           //Builder建造者对象提供内置属性与各种set⽅法，注意set⽅法返回Builder对象本身
           private String xxx ;
           public Builder setXxx(String xxx) {
               this.xxx = xxx;
               return this;
           }
           //Builder建造者类提供build()⽅法实现⽬标类对象的创建
           public ⽬标类 build() {
               //业务校验
               return new ⽬标类(this);
           }
       }
   }
   ```

2. 示例

   ```java
   public class RabbitMQClient {
       private RabbitMQClient(Builder builder){
           
       }
       public void sendMessage(String msg) {
           System.out.println("正在发送消息：" + msg);
       }
       // Builder
       public static class Builder {
           private String host = "127.0.0.1";
           private int port = 5672;
           private int mode;
           private String exchange;
           private String queue;
           private boolean isDurable = true;
           private int connectionTimeout = 20;
           public Builder setHost(String host) {
               this.host = host;
               return this;
           }
           public Builder setPort(int port) {
               this.port = port;
               return this;
           }
           public Builder setMode(int mode) {
               this.mode = mode;
               return this;
           }
           public Builder setExchange(String exchange) {
               this.exchange = exchange;
               return this;
           }
           public Builder setQueue(String queue) {
               this.queue = queue;
               return this;
           }
           public Builder setDurable(boolean durable) {
               isDurable = durable;
               return this;
           }
           public RabbitMQClient build() {
               if(mode == 1){ //⼯作队列模式不需要设置交换机，但queue必填
                   if(exchange != null){
                       throw new RuntimeException("⼯作队列模式⽆须设计交换机");
                   }
                   if(queue == null || queue.trim().equals("")){
                       throw new RuntimeException("⼯作队列模式必须设置队列名称");
                   }
                   if(isDurable == false){
                       throw new RuntimeException("⼯作队列模式必须开启数据持久化");
                   }
               } else if(mode ==2) { //路由模式必须设置交换机，但不能设置queue队列
                   if(exchange == null || exchange.trim().equals("")){
                       throw new RuntimeException("路由模式请设置交换机");
                   }
                   if(queue != null){
                       throw new RuntimeException("路由模式⽆须设置队列名称");
                   }
               }
               //其他验证
               return new RabbitMQClient(this);
           }
       }
       public static void main(String[] args) {
           RabbitMQClient client = new RabbitMQClient.Builder()
               .setHost("192.168.31.201")
               .setMode(2)
               .setExchange("test-exchange")
               .build();
           client.sendMessage("Test");
       }
   }
   ```

## 四、原型模式

### 概述：

1. ⽤⼀个已经创建的实例作为原型，通过复制该原型对象来创建⼀个和原型相同或相似的新对象。在这⾥，原型实例指定了要创建的对象的种类。⽤这种⽅式创建对象⾮常⾼效，根本⽆须知道对象创建的细节。
2. 这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。

### 代码示例：

#### a.浅克隆

实例对象中的引用类型的属性，仍指向原有属性所指向的对象的内存地址。

1. 实现Clonable接口的clone()方法

   ```java
   public class Employee implements Cloneable{
       private String name;
       private Car car;
       public String getName() {
           return name;
       }
       public void setName(String name) {
           this.name = name;
       }
       public Car getCar() {
           return car;
       }
       public void setCar(Car car) {
           this.car = car;
       }
       //重写Clone⽅法
       @Override
       protected Object clone() throws CloneNotSupportedException {
           System.out.println("正在复制Employee对象");
           return super.clone();
       }
   }
   ```

2. 应用入口

   ```java
   public class App {
       public static void main(String[] args) throws CloneNotSupportedException {
           Employee king = new Employee();
           king.setName("King");
           Car car = new Car();
           car.setNumber("FBW 381");
           king.setCar(car);
           Employee cloneKing = (Employee)king.clone();
           System.out.println("King == CloneKing:" + (king == cloneKing));
           System.out.println("King.car == CloneKing.car:" + (king.getCar() == cloneKing.getCar()));
       }
   }
   ```

#### b.深克隆

创建⼀个新对象，属性中引⽤的其他对象也会被克隆，不再指向原有对象地址。

```java
import com.google.gson.Gson;
public class Employee{
    private String name;
    private Car car;
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public Car getCar() {
        return car;
    }
    public void setCar(Car car) {
        this.car = car;
    }
    //基于JSON实现深度序列化
    public Employee deepClone(){
        Gson gson = new Gson();
        String json = gson.toJson(this);
        System.out.println(json);
        Employee cloneObject = gson.fromJson(json, Employee.class);
        return cloneObject;
    }
}
```

# 结构型模式

# 行为型模式